\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Percabangan}

\section*{Tujuan Praktikum}
Setelah menyelesaikan praktikum ini, mahasiswa diharapkan mampu:
\begin{itemize}
  \item Memahami konsep dan jenis-jenis percabangan (satu arah, dua arah, banyak arah)
  \item Mengimplementasikan percabangan if, if-else, dan if-else if-else
  \item Menggunakan nested if untuk kondisi bertingkat
  \item Mengimplementasikan switch/case untuk pilihan multi-cabang
  \item Memahami short-circuit evaluation pada operator logika
  \item Menggunakan operator bitwise dalam struktur kontrol kondisional
  \item Memilih struktur percabangan yang tepat untuk berbagai kasus pemrograman
\end{itemize}

\section{Klasifikasi Percabangan}
Struktur kontrol kondisional—atau yang biasa kita sebut percabangan—adalah mekanisme yang memungkinkan program untuk mengambil keputusan berdasarkan evaluasi kondisi tertentu. Kita dapat mengelompokkan percabangan ke dalam beberapa kategori berdasarkan berapa banyak pilihan eksekusi yang tersedia: percabangan dengan satu jalur, dua jalur, atau bahkan multiple pathways.

\subsection{Tabel Perbandingan Jenis Percabangan}
\begin{table}[H]
  \centering
  \caption{Perbandingan jenis percabangan}
  \begin{tabular}{@{}llll@{}}
    \toprule
    Jenis & Struktur & Jumlah Pilihan & Kegunaan \\
    \midrule
    Satu arah & \texttt{if} & 1 (eksekusi atau lewati) & Validasi, aksi opsional \\
    Dua arah & \texttt{if-else} & 2 & Pilihan biner (ya/tidak) \\
    Banyak arah & \texttt{if-else if-else} & 3+ & Klasifikasi, grading \\
    Bersarang & \texttt{nested if} & Bertingkat & Kondisi kompleks \\
    Multi-cabang & \texttt{switch/case} & 3+ & Pilihan diskret/enumerasi \\
    \bottomrule
  \end{tabular}
\end{table}

Pemilihan jenis percabangan yang tepat sangat bergantung pada seberapa kompleks logika yang hendak kita implementasikan. Untuk validasi sederhana, percabangan satu arah sudah cukup. Keputusan biner (ya/tidak) paling baik ditangani dengan percabangan dua arah. Klasifikasi bertingkat memerlukan percabangan multi-directional. Kondisi yang saling terkait dan kompleks cocok dengan nested branching. Sedangkan untuk pilihan-pilihan diskret dengan nilai yang jelas, \texttt{switch/case} adalah solusi paling elegan.

\subsection{Diagram Alur Percabangan}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.7cm, >=Stealth]
    \tikzstyle{b}=[rectangle, draw, rounded corners, align=center, minimum width=3.0cm, minimum height=1cm]
    \node[b] (start) {Mulai};
    \node[b, below=of start] (cond) {n genap?};
    \node[b, below left=1.2cm and 1.6cm of cond] (yes) {Cetak "Genap"};
    \node[b, below right=1.2cm and 1.6cm of cond] (no) {Cetak "Ganjil"};
    \node[b, below=2.2cm of cond] (end) {Selesai};
    \draw[->] (start) -- (cond);
    \draw[->] (cond) -- node[left]{Ya} (yes);
    \draw[->] (cond) -- node[right]{Tidak} (no);
    \draw[->] (yes) |- (end);
    \draw[->] (no)  |- (end);
  \end{tikzpicture}
  \caption{Alur keputusan dua arah sederhana}
\end{figure}

\subsection{Percabangan Satu Arah (Single Selection)}
Percabangan satu arah adalah bentuk paling sederhana dari conditional statement—blok kode di dalamnya hanya akan dieksekusi jika kondisi bernilai \texttt{true}. Apabila kondisi evaluasinya \texttt{false}, maka program akan melewati blok tersebut dan langsung melanjutkan ke statement berikutnya. Pattern ini sangat berguna ketika kita hanya perlu melakukan aksi tertentu pada kondisi yang sangat spesifik.

Program berikut mengevaluasi apakah nilai yang dimasukkan user mencapai atau melebihi threshold 75, dan hanya menampilkan pesan kelulusan jika syarat tersebut terpenuhi:

\begin{lstlisting}[language=Pascal, caption={Percabangan satu arah di Pascal}]
program SatuArah;
var
  nilai: integer;
begin
  Write('Masukkan nilai: ');
  Readln(nilai);
  if nilai >= 75 then
    Writeln('Selamat, Anda lulus!');
  Writeln('Program selesai.');
end.
\end{lstlisting}

Konsep yang sama diterapkan di C dengan sintaks conditional yang familiar bagi programmer C:

\begin{lstlisting}[language=C, caption={Percabangan satu arah di C}]
#include <stdio.h>
int main(void) {
  int nilai;
  printf("Masukkan nilai: ");
  scanf("%d", &nilai);
  if (nilai >= 75)
    printf("Selamat, Anda lulus!\n");
  printf("Program selesai.\n");
  return 0;
}
\end{lstlisting}

Di C++, kita menggunakan stream-based I/O, tetapi logika conditional-nya tetap sama persis:

\begin{lstlisting}[language=C++, caption={Percabangan satu arah di C++}]
#include <iostream>
using namespace std;

int main() {
  int nilai;
  cout << "Masukkan nilai: ";
  cin >> nilai;
  if (nilai >= 75)
    cout << "Selamat, Anda lulus!\n";
  cout << "Program selesai.\n";
}
\end{lstlisting}

\subsection{Percabangan Dua Arah (Double Selection)}
Percabangan dua arah memberikan dua opsi eksekusi yang mutually exclusive: satu blok kode akan dijalankan jika kondisi bernilai true, dan blok lainnya akan dijalankan jika kondisi false. Dengan konstruksi \texttt{if-else}, program dijamin akan selalu mengeksekusi tepat satu dari dua cabang yang tersedia—tidak lebih, tidak kurang.

Contoh berikut mengklasifikasikan usia user ke dalam kategori "dewasa" atau "di bawah umur", dengan menggunakan batasan usia 17 tahun sebagai titik pemisah:

\begin{lstlisting}[language=Pascal, caption={Percabangan dua arah di Pascal}]
program DuaArah;
var
  umur: integer;
begin
  Write('Masukkan umur: ');
  Readln(umur);
  if umur >= 17 then
    Writeln('Anda sudah dewasa')
  else
    Writeln('Anda masih di bawah umur');
end.
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Percabangan dua arah di C}]
#include <stdio.h>
int main(void) {
  int umur;
  printf("Masukkan umur: ");
  scanf("%d", &umur);
  if (umur >= 17)
    printf("Anda sudah dewasa\n");
  else
    printf("Anda masih di bawah umur\n");
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Percabangan dua arah di C++}]
#include <iostream>
using namespace std;

int main() {
  int umur;
  cout << "Masukkan umur: ";
  cin >> umur;
  if (umur >= 17)
    cout << "Anda sudah dewasa\n";
  else
    cout << "Anda masih di bawah umur\n";
}
\end{lstlisting}

\subsection{Percabangan Banyak Arah (Multiple Selection)}
Percabangan banyak arah menawarkan lebih dari dua jalur eksekusi melalui konstruksi \texttt{if-else if-else} atau dengan pendekatan nested branching. Pattern ini sangat cocok digunakan ketika kita perlu mengevaluasi banyak kondisi secara sequential, dimana hanya satu kondisi yang akan match dan dieksekusi.

Program grading di bawah ini mengilustrasikan bagaimana nilai mahasiswa diklasifikasikan ke dalam lima kategori grade (A sampai E) dengan menggunakan chain of conditional statements:

\begin{lstlisting}[language=Pascal, caption={Percabangan banyak arah di Pascal}]
program BanyakArah;
var
  nilai: integer;
begin
  Write('Masukkan nilai (0-100): ');
  Readln(nilai);
  if nilai >= 85 then
    Writeln('Grade: A')
  else if nilai >= 70 then
    Writeln('Grade: B')
  else if nilai >= 55 then
    Writeln('Grade: C')
  else if nilai >= 40 then
    Writeln('Grade: D')
  else
    Writeln('Grade: E');
end.
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Percabangan banyak arah di C}]
#include <stdio.h>
int main(void) {
  int nilai;
  printf("Masukkan nilai (0-100): ");
  scanf("%d", &nilai);
  if (nilai >= 85)
    printf("Grade: A\n");
  else if (nilai >= 70)
    printf("Grade: B\n");
  else if (nilai >= 55)
    printf("Grade: C\n");
  else if (nilai >= 40)
    printf("Grade: D\n");
  else
    printf("Grade: E\n");
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Percabangan banyak arah di C++}]
#include <iostream>
using namespace std;

int main() {
  int nilai;
  cout << "Masukkan nilai (0-100): ";
  cin >> nilai;
  if (nilai >= 85)
    cout << "Grade: A\n";
  else if (nilai >= 70)
    cout << "Grade: B\n";
  else if (nilai >= 55)
    cout << "Grade: C\n";
  else if (nilai >= 40)
    cout << "Grade: D\n";
  else
    cout << "Grade: E\n";
}
\end{lstlisting}

\subsection{Percabangan Bersarang (Nested If)}
Percabangan bersarang terjadi ketika kita menempatkan statement \texttt{if} di dalam statement \texttt{if} yang lain. Pattern ini dipakai ketika decision-making process kita bergantung pada evaluasi multiple conditions secara hierarkis. Namun perlu diingat: nesting yang terlalu dalam akan membuat kode sulit dibaca dan di-maintain. Sebisa mungkin, batasi tingkat nesting untuk menjaga code clarity.

Contoh program berikut melakukan pemeriksaan bertingkat: level pertama mengevaluasi nilai akademik, kemudian jika lulus dari level pertama, akan dilakukan pengecekan persentase kehadiran untuk menentukan status final:

\begin{lstlisting}[language=Pascal, caption={Nested if di Pascal}]
program NestedIf;
var
  nilai: integer;
  kehadiran: integer;
begin
  Write('Masukkan nilai: ');
  Readln(nilai);
  Write('Masukkan kehadiran (%): ');
  Readln(kehadiran);
  
  if nilai >= 75 then begin
    if kehadiran >= 80 then
      Writeln('Lulus dengan baik')
    else
      Writeln('Lulus, tapi kehadiran kurang');
  end else begin
    Writeln('Tidak lulus');
  end;
end.
\end{lstlisting}

\begin{lstlisting}[language=C, caption={Nested if di C}]
#include <stdio.h>
int main(void) {
  int nilai, kehadiran;
  printf("Masukkan nilai: ");
  scanf("%d", &nilai);
  printf("Masukkan kehadiran (%%): ");
  scanf("%d", &kehadiran);
  
  if (nilai >= 75) {
    if (kehadiran >= 80)
      printf("Lulus dengan baik\n");
    else
      printf("Lulus, tapi kehadiran kurang\n");
  } else {
    printf("Tidak lulus\n");
  }
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Nested if di C++}]
#include <iostream>
using namespace std;

int main() {
  int nilai, kehadiran;
  cout << "Masukkan nilai: ";
  cin >> nilai;
  cout << "Masukkan kehadiran (%): ";
  cin >> kehadiran;
  
  if (nilai >= 75) {
    if (kehadiran >= 80)
      cout << "Lulus dengan baik\n";
    else
      cout << "Lulus, tapi kehadiran kurang\n";
  } else {
    cout << "Tidak lulus\n";
  }
}
\end{lstlisting}

\subsection{Short-circuit Evaluation pada Kondisi}
Dalam bahasa C dan C++, operator logika \texttt{\&\&} serta \texttt{||} mengimplementasikan mekanisme lazy evaluation yang dikenal sebagai \emph{short-circuit}. Artinya, operand di sisi kanan hanya akan dievaluasi jika memang diperlukan untuk menentukan hasil akhir. Untuk operator \texttt{\&\&} (AND), jika operand kiri sudah bernilai \texttt{false}, maka operand kanan akan di-skip karena hasil pasti false. Begitu pula dengan operator \texttt{||} (OR)—jika operand kiri sudah \texttt{true}, operand kanan tidak akan diperiksa. Karakteristik ini sangat berguna untuk menulis kondisi yang tidak hanya efisien, tetapi juga aman dari runtime errors \parencite{gnu-c-manual,cpp-reference}.

\begin{lstlisting}[language=C, caption={Short-circuit di C untuk keamanan}]
#include <stdio.h>

int main(void) {
  int nilai = 0;
  int pembagi = 0;
  
  // Aman: pembagian TIDAK dilakukan karena pembagi == 0
  if (pembagi != 0 && nilai / pembagi > 10) {
    printf("Hasil pembagian lebih dari 10\n");
  } else {
    printf("Pembagi nol atau hasil <= 10\n");
  }
  
  // Operator OR: kondisi kedua dicek hanya jika pertama false
  int x = 5;
  if (x > 10 || x < 0) {
    printf("x di luar rentang [0, 10]\n");
  } else {
    printf("x dalam rentang [0, 10]\n");
  }
  
  return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Short-circuit di C++ untuk efisiensi}]
#include <iostream>
using namespace std;

int main() {
  int panjang = 0;
  int nilai = 75;
  
  // Short-circuit: kondisi kedua tidak dievaluasi jika pertama false
  if (panjang > 0 && nilai / panjang > 50) {
    cout << "Rata-rata tinggi\n";
  } else {
    cout << "Panjang nol atau rata-rata rendah\n";
  }
  
  // Efisien: cek sederhana dulu sebelum cek kompleks
  int angka = 5;
  if (angka < 0 || angka > 100) {
    cout << "Angka di luar rentang [0, 100]\n";
  } else {
    cout << "Angka valid\n";
  }
  
  return 0;
}
\end{lstlisting}

Di Pascal, perilaku evaluasi boolean bisa bervariasi tergantung pada compiler option yang digunakan (ada mode boolean evaluation yang berbeda-beda). Untuk memastikan keamanan, lebih baik gunakan pendekatan pemeriksaan step-by-step menggunakan nested if statement, sehingga Anda bisa mengontrol urutan evaluasi kondisi dengan pasti \parencite{free-pascal-docs}.

\begin{lstlisting}[language=Pascal, caption={Pemeriksaan bertahap di Pascal}]
program SafeCheck;
var
  a, b: integer;
begin
  a := 10;
  b := 0;
  { Pemeriksaan bertahap untuk menghindari division by zero }
  if b <> 0 then begin
    if a / b > 1 then
      Writeln('Rasio lebih dari 1');
  end else begin
    Writeln('b adalah nol, tidak bisa dibagi');
  end;
end.
\end{lstlisting}

Hindari menempatkan side effects (seperti increment, assignment, atau function call) pada operand dari conditional expression yang mungkin tidak dievaluasi akibat short-circuit. Selalu tulis kondisi yang clear dan predictable agar debugging menjadi lebih mudah.

\subsection{Pola Early Return vs Nested If}
Ketika level nesting pada nested if semakin dalam, kode akan semakin sulit dipahami dan di-maintain. Pattern \emph{early return} menawarkan solusi yang lebih elegan dengan cara keluar dari fungsi sedini mungkin ketika suatu kondisi tertentu terpenuhi. Pendekatan ini tidak hanya meningkatkan readability, tetapi juga mengurangi cognitive load ketika membaca kode.
\begin{lstlisting}[language=C]
int process(const char* path) {
  if (!path) return -1;           // validasi awal
  FILE* f = fopen(path, "r");
  if (!f) return -2;              // gagal buka
  // ... proses ...
  fclose(f);
  return 0;
}
\end{lstlisting}

\section{Pernyataan \texttt{case} / \texttt{switch}}
Struktur multi-branch \texttt{case} (Pascal) atau \texttt{switch} (C/C++) dirancang khusus untuk menangani pilihan-pilihan diskret yang berbasis nilai konstan. Pascal menyediakan \texttt{case\ldots of} yang bahkan mendukung range values. Sementara C/C++ menggunakan \texttt{switch} dengan \texttt{case} labels untuk konstanta integral. Untuk menjaga robustness, selalu sertakan klausa \texttt{else} (Pascal) atau \texttt{default} (C/C++) untuk menangani nilai-nilai yang tidak terduga \parencite{pascal-tutorial-wikibooks,gnu-c-manual,cpp-reference,cpp-switch,cpp-enum-class}.

\subsection{Kapan Menggunakan \texttt{switch} vs \texttt{if-else if}}
\begin{itemize}
  \item Gunakan \texttt{switch/case} ketika: Anda perlu mengevaluasi pilihan-pilihan diskret berdasarkan satu variabel dengan nilai konstan (integer, character, atau enumeration). Structure ini lebih efisien dan readable untuk multiple distinct choices.
  \item Gunakan \texttt{if-else if} ketika: Kondisi yang diperiksa lebih kompleks, melibatkan range values, atau memerlukan evaluasi boolean expressions yang berbeda-beda. Konstruksi ini lebih flexible untuk logic yang bervariasi.
\end{itemize}

\subsection{Contoh Menu dengan \texttt{switch/case}}

Program-program menu berikut memperlihatkan bagaimana \texttt{case}/\texttt{switch} digunakan untuk menangani user selection dan menjalankan aksi yang sesuai:

\begin{lstlisting}[language=Pascal, caption={Menu dengan case di Pascal}]
program MenuSwitch;
var
  pilihan: char;
begin
  Writeln('=== Menu Utama ===');
  Writeln('1. Input data');
  Writeln('2. Tampilkan data');
  Writeln('3. Hapus data');
  Writeln('0. Keluar');
  Write('Pilih menu: ');
  Readln(pilihan);
  
  case pilihan of
    '1': Writeln('Anda memilih Input data');
    '2': Writeln('Anda memilih Tampilkan data');
    '3': Writeln('Anda memilih Hapus data');
    '0': Writeln('Keluar dari program');
  else
    Writeln('Pilihan tidak valid');
  end;
end.
\end{lstlisting}

Dalam bahasa C, statement \texttt{break} sangat krusial dalam \texttt{switch} untuk mencegah fall-through behavior dimana eksekusi berlanjut ke case berikutnya:

\begin{lstlisting}[language=C, caption={Menu dengan switch di C}]
#include <stdio.h>
int main(void) {
  char pilihan;
  printf("=== Menu Utama ===\n");
  printf("1. Input data\n");
  printf("2. Tampilkan data\n");
  printf("3. Hapus data\n");
  printf("0. Keluar\n");
  printf("Pilih menu: ");
  scanf(" %c", &pilihan);
  
  switch (pilihan) {
    case '1':
      printf("Anda memilih Input data\n");
      break;
    case '2':
      printf("Anda memilih Tampilkan data\n");
    break;
    case '3':
      printf("Anda memilih Hapus data\n");
    break;
    case '0':
      printf("Keluar dari program\n");
    break;
  default:
      printf("Pilihan tidak valid\n");
  }
  return 0;
}
\end{lstlisting}

C++ menawarkan enum class yang membuat pilihan menu menjadi lebih type-safe, self-documenting, dan mudah di-maintain:

\begin{lstlisting}[language=C++, caption={Menu dengan switch dan enum di C++}]
#include <iostream>
using namespace std;

enum class Menu { INPUT = 1, TAMPIL = 2, HAPUS = 3, KELUAR = 0 };

int main() {
  int pilihan;
  cout << "=== Menu Utama ===\n";
  cout << "1. Input data\n";
  cout << "2. Tampilkan data\n";
  cout << "3. Hapus data\n";
  cout << "0. Keluar\n";
  cout << "Pilih menu: ";
  cin >> pilihan;
  
  switch (static_cast<Menu>(pilihan)) {
    case Menu::INPUT:
      cout << "Anda memilih Input data\n";
      break;
    case Menu::TAMPIL:
      cout << "Anda memilih Tampilkan data\n";
      break;
    case Menu::HAPUS:
      cout << "Anda memilih Hapus data\n";
      break;
    case Menu::KELUAR:
      cout << "Keluar dari program\n";
      break;
    default:
      cout << "Pilihan tidak valid\n";
  }
}
\end{lstlisting}

Perlu diperhatikan bahwa dalam C/C++, setiap \texttt{case} label memerlukan statement \texttt{break} untuk menghentikan eksekusi dan mencegah fall-through ke case selanjutnya—kecuali memang fall-through adalah behavior yang Anda inginkan. Dalam C++ modern (C++17 onwards), jika fall-through intentional, gunakan attribute \texttt{[[fallthrough]]} untuk membuat intention menjadi eksplisit \parencite{cpp-fallthrough-attr}. Berbeda dengan C/C++, Pascal secara default tidak mengalami fall-through behavior.

\subsection{Rentang \texttt{case} di Pascal}
Salah satu fitur menarik dari Pascal adalah dukungan native untuk range values dalam \texttt{case} statement. Ini membuat klasifikasi interval nilai menjadi jauh lebih straightforward.

Program berikut memanfaatkan fitur range ini untuk mengklasifikasikan score ke dalam grade dengan syntax yang compact dan readable:

\begin{lstlisting}[language=Pascal, caption={Rentang case di Pascal}]
program CaseRange;
var
  skor: integer;
begin
  Readln(skor);
  case skor of
    85..100: Writeln('A');
    70..84:  Writeln('B');
    55..69:  Writeln('C');
    40..54:  Writeln('D');
    0..39:   Writeln('E');
  else
    Writeln('Di luar rentang');
  end;
end.
\end{lstlisting}

\subsection{Masalah Klasik: Dangling else}
Salah satu pitfall klasik dalam nested if tanpa braces yang eksplisit adalah \emph{dangling else} problem—dimana \texttt{else} clause akan berasosiasi dengan \texttt{if} terdekat, yang mungkin bukan yang Anda inginkan. Untuk menghindari ambiguitas, selalu gunakan curly braces \texttt{\{\}} di C/C++ atau \texttt{begin..end} di Pascal untuk setiap block.
\begin{lstlisting}[language=C, caption={Dangling else dan solusinya}]
if (cond1)
  if (cond2)
    action();
else
  fix(); // else ini mengikat ke if (cond2), mungkin tidak diharapkan

// Solusi aman:
if (cond1) {
  if (cond2) {
    action();
  } else {
    fix();
  }
}
\end{lstlisting}

\section{Operator Bitwise dalam Kondisi}
Operator bitwise bekerja langsung pada level bit dari representasi biner data. Di C/C++, operator-operator ini meliputi \texttt{\&} (AND), \texttt{|} (OR), \texttt{\^{}} (XOR), \texttt{\~{}} (NOT), serta \texttt{\textless\textless} dan \texttt{\textgreater\textgreater} untuk shifting. Pascal memiliki operator setara: \texttt{and}, \texttt{or}, \texttt{xor}, \texttt{not}, dan \texttt{shl}/\texttt{shr} untuk shift operations. Operator-operator ini sangat powerful dalam conditional control structures untuk manage flags, bit status, dan conditional checking berbasis bit \parencite{free-pascal-docs,iso-c-draft-n1570,cpp-reference}.

Dalam konteks branching, bitwise operators memungkinkan kita untuk mengecek multiple conditions secara simultan melalui bit flags, serta melakukan manipulasi state yang efficient—hal ini sangat berguna dalam system programming, network protocols, dan embedded systems development.

\subsection{Contoh Flags dalam Percabangan}

Program-program berikut mengilustrasikan bagaimana bit flags digunakan untuk merepresentasikan permissions (READ, WRITE, EXEC). Kita akan melihat bagaimana cara check, set, dan clear individual flags menggunakan bitwise operators di dalam conditional structures:

\begin{lstlisting}[language=C, caption={Bit flags dengan kondisi di C}]
#include <stdio.h>

enum { READ = 1<<0, WRITE = 1<<1, EXEC = 1<<2 };

int main(void) {
  unsigned mask = READ | WRITE;  // set dua bit
  
  // Percabangan berdasarkan bit flags
  if (mask & READ) {
    printf("READ permission on\n");
  }
  
  if (mask & WRITE) {
    printf("WRITE permission on\n");
  }
  
  if (mask & EXEC) {
    printf("EXEC permission on\n");
  } else {
    printf("EXEC permission off\n");
  }
  
  // Clear satu bit
  mask &= ~WRITE;
  
  // Cek kombinasi flags
  if ((mask & (READ | WRITE)) == (READ | WRITE)) {
    printf("Both READ and WRITE on\n");
  } else {
    printf("Not both READ and WRITE\n");
  }
  
  return 0;
}
\end{lstlisting}

Implementasi serupa di Pascal memanfaatkan bitwise operators yang tersedia (\texttt{shl}, \texttt{and}, \texttt{or}, \texttt{not}):

\begin{lstlisting}[language=Pascal, caption={Pergeseran dan bitwise dengan kondisi di Pascal}]
program BitwiseFlags;
const
  READ  = 1 shl 0;  // bit 0
  WRITE = 1 shl 1;  // bit 1
  EXEC  = 1 shl 2;  // bit 2
var
  mask: longint;
begin
  mask := READ or WRITE;  // set bit 0 dan 1
  
  { Percabangan berdasarkan bit flags }
  if (mask and READ) <> 0 then
    Writeln('READ permission on');
  
  if (mask and WRITE) <> 0 then
    Writeln('WRITE permission on');
  
  if (mask and EXEC) <> 0 then
    Writeln('EXEC permission on')
  else
    Writeln('EXEC permission off');
  
  { Clear satu bit }
  mask := mask and not WRITE;
  
  { Cek lagi setelah perubahan }
  if (mask and WRITE) <> 0 then
    Writeln('WRITE still on')
  else
    Writeln('WRITE cleared');
end.
\end{lstlisting}

Versi C++ memanfaatkan enum untuk define flag constants, dan menyertakan helper function untuk print permissions dalam format yang user-friendly:

\begin{lstlisting}[language=C++, caption={Bitwise flags dengan switch di C++}]
#include <iostream>
using namespace std;

enum Permission {
  NONE  = 0,
  READ  = 1 << 0,
  WRITE = 1 << 1,
  EXEC  = 1 << 2,
  ALL   = READ | WRITE | EXEC
};

void checkPermissions(unsigned perm) {
  cout << "Permissions: ";
  
  if (perm & READ)  cout << "R";
  else cout << "-";
  
  if (perm & WRITE) cout << "W";
  else cout << "-";
  
  if (perm & EXEC)  cout << "X";
  else cout << "-";
  
  cout << "\n";
}

int main() {
  unsigned userPerm = READ | WRITE;
  
  checkPermissions(userPerm);
  
  // Percabangan berdasarkan kombinasi
  if ((userPerm & (READ | WRITE)) == (READ | WRITE)) {
    cout << "User can read and write\n";
  }
  
  // Toggle bit
  userPerm ^= EXEC;  // add EXEC
  checkPermissions(userPerm);
  
  userPerm ^= EXEC;  // remove EXEC
  checkPermissions(userPerm);
  
  return 0;
}
\end{lstlisting}

\subsection{Pola Umum Operasi Bit Flags}
\begin{table}[H]
  \centering
  \caption{Operasi umum bit flags dalam kondisi}
  \begin{tabular}{@{}lll@{}}
    \toprule
    Operasi & C/C++ & Pascal \\
    \midrule
    Set bit & \texttt{mask |= FLAG} & \texttt{mask := mask or FLAG} \\
    Clear bit & \texttt{mask \&= \~{}FLAG} & \texttt{mask := mask and not FLAG} \\
    Toggle bit & \texttt{mask \^{}= FLAG} & \texttt{mask := mask xor FLAG} \\
    Check bit & \texttt{if (mask \& FLAG)} & \texttt{if (mask and FLAG) {\textless}{\textgreater} 0} \\
    Check all & \texttt{if ((mask \& FLAGS) == FLAGS)} & \texttt{if (mask and FLAGS) = FLAGS} \\
    \bottomrule
  \end{tabular}
\end{table}

Perlu berhati-hati ketika melakukan shift operations pada signed types: right shift dapat melakukan sign extension pada beberapa implementations. Pastikan jumlah shift tidak melebihi bit-width dari tipe data yang digunakan. Untuk conditional expressions yang complex, gunakan parentheses untuk memperjelas operator precedence—khususnya antara bitwise operators dengan relational dan logical operators \parencite{iso-c-draft-n1570,cpp-reference}.

\section{Rangkuman Materi}
\begin{itemize}
  \item Kita telah membahas klasifikasi lengkap struktur percabangan: dari single-direction, double-direction, multiple-direction, nested branching, hingga multi-branch statements.
  \item Best practices untuk conditional safety telah dijelaskan: menghindari \emph{dangling else} ambiguity, selalu menggunakan explicit blocks, dan memanfaatkan enum class di C++ untuk type safety.
  \item Guideline pemilihan antara \texttt{switch/case} versus \texttt{if-else if} telah diuraikan, termasuk penggunaan attribute \texttt{[[fall\-through]]} di C++ modern untuk intentional fall-through.
  \item Penggunaan bit flags dalam conditional structures dipelajari secara mendalam, mencakup pattern untuk set/clear/toggle/check bits, lengkap dengan comparison table across languages.
  \item Flowchart diagram dan contoh menu application yang terstruktur telah disediakan untuk ketiga bahasa: Pascal, C, dan C++.
\end{itemize}

\end{document}
