\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Perulangan}

\section*{Tujuan Praktikum}
Setelah menyelesaikan praktikum ini, mahasiswa diharapkan mampu:
\begin{itemize}
  \item Memahami konsep dan jenis-jenis perulangan (for, while, repeat-until, do-while)
  \item Memilih bentuk loop yang sesuai berdasarkan kondisi masalah
  \item Mengimplementasikan nested loop untuk masalah multidimensi
  \item Menggunakan break dan continue untuk kontrol alur loop
  \item Menghindari infinite loop dan off-by-one error
  \item Membuat program dengan pola output menggunakan nested loop
  \item Mengoptimalkan efisiensi loop untuk performa yang lebih baik
\end{itemize}

\section{Perulangan: \texttt{for}, \texttt{while}, \texttt{repeat} / \texttt{do\textendash while}}
Pemilihan bentuk loop yang tepat bergantung pada dua faktor utama: apakah kita sudah tahu berapa kali iterasi akan berjalan, dan pada titik mana kondisi perlu dicek (di awal atau di akhir loop body). Pascal menyediakan tiga konstruksi: \texttt{for}, \texttt{while}, dan \texttt{repeat\ldots until}. Sementara C/C++ menawarkan \texttt{for}, \texttt{while}, dan \texttt{do\ldots while} \parencite{free-pascal-docs,gnu-c-manual,cpp-reference}.

\subsection{Ringkasan Pemilihan Bentuk Loop}
\begin{table}[H]
  \centering
  \caption{Kapan memakai bentuk loop}
  \begin{tabular}{@{}lll@{}}
    \toprule
    Bentuk & Kapan dipakai & Catatan \\
    \midrule
    while & Iterasi tak diketahui, cek di awal & Bisa 0 iterasi \\
    do-while/repeat-until & Harus jalan minimal sekali & Cek di akhir \\
    for & Indeks berhingga, batas jelas & Hati-hati off-by-one \\
    range-based for (C++) & Koleksi/iterator modern & Lebih aman dan ringkas \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Diagram Alur Loop}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.7cm, >=Stealth]
    \tikzstyle{b}=[rectangle, draw, rounded corners, align=center, minimum width=3.0cm, minimum height=1cm]
    % while
    \node[b] (start) {Mulai};
    \node[b, below=of start] (cond) {kondisi?};
    \node[b, below=of cond] (body) {badan loop};
    \node[b, below=of body] (end) {Selesai};
    \draw[->] (start) -- (cond);
    \draw[->] (cond) -- node[right]{Ya} (body);
    \draw[->] (body) -- +( -3.0, 0) |- (cond);
    \draw[->] (cond.east) -- +(3.0,0) |- node[pos=0.25,right]{Tidak} (end);
  \end{tikzpicture}
  \caption{Skema \texttt{while}: cek di awal, mungkin 0 iterasi}
\end{figure}

\subsection{Diagram Alur \texttt{repeat-until} / \texttt{do-while}}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.7cm, >=Stealth]
    \tikzstyle{b}=[rectangle, draw, rounded corners, align=center, minimum width=3.0cm, minimum height=1cm]
    \node[b] (start) {Mulai};
    \node[b, below=of start] (body) {badan loop};
    \node[b, below=of body] (cond) {kondisi?};
    \node[b, below=of cond] (end) {Selesai};
    \draw[->] (start) -- (body);
    \draw[->] (body) -- (cond);
    \draw[->] (cond) -- node[right]{Tidak (C)} (end);
    \draw[->] (cond.west) -- +(-2.0, 0) |- node[pos=0.25,left]{Ya (C)} (body);
    \node[right=0.3cm of cond] {\footnotesize Pascal: until true keluar};
  \end{tikzpicture}
  \caption{Skema \texttt{do-while}/\texttt{repeat-until}: cek di akhir, minimal 1 iterasi}
\end{figure}

\subsection{Contoh Loop \texttt{for}}

Program-program berikut mendemonstrasikan penggunaan \texttt{for} loop untuk menghasilkan tabel perkalian berdasarkan input dari user:

\begin{lstlisting}[language=Pascal, caption={Cetak tabel perkalian dengan for (Pascal)}]
program TabelPerkalian;
var
  i, angka, hasil: integer;
begin
  Write('Masukkan angka: ');
  Readln(angka);
  for i := 1 to 10 do begin
    hasil := angka * i;
    Writeln(angka, ' x ', i, ' = ', hasil);
  end;
end.
\end{lstlisting}

Dalam bahasa C, \texttt{for} loop sangat cocok untuk menghitung faktorial melalui iterasi sequential dari 1 sampai n:

\begin{lstlisting}[language=C, caption={Hitung faktorial dengan for (C)}]
#include <stdio.h>
int main(void) {
  int n;
  unsigned long faktorial = 1;
  printf("Masukkan n: ");
  scanf("%d", &n);
  
  for (int i = 1; i <= n; ++i) {
    faktorial *= i;
  }
  printf("Faktorial %d = %lu\n", n, faktorial);
  return 0;
}
\end{lstlisting}

Contoh C++ berikut memanfaatkan loop untuk membaca multiple values dari input, kemudian menghitung sum dan average-nya:

\begin{lstlisting}[language=C++, caption={Loop for dengan hitung total (C++)}]
#include <iostream>
using namespace std;

int main() {
  int total = 0;
  int jumlah = 5;
  
  cout << "Masukkan " << jumlah << " nilai:\n";
  for (int i = 0; i < jumlah; ++i) {
    int nilai;
    cout << "Nilai ke-" << (i+1) << ": ";
    cin >> nilai;
    total += nilai;
  }
  
  cout << "Total: " << total << "\n";
  cout << "Rata-rata: " << (double)total / jumlah << "\n";
}
\end{lstlisting}

Sejak C++11, tersedia range-based for loop yang sintaksnya jauh lebih compact untuk iterate collections tanpa harus menggunakan index secara eksplisit:

\begin{lstlisting}[language=C++, caption={Range-based for pada koleksi (C++11+)}]
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> data{1,2,3,4,5};
  int total = 0;
  for (int v : data) { // tidak perlu indeks eksplisit
    total += v;
  }
  cout << total << "\n";
}
\end{lstlisting}

\subsection{Contoh Loop \texttt{while}}

Program-program berikut menggunakan \texttt{while} loop untuk input validation—memaksa user memasukkan angka positif dan terus meminta input hingga syarat terpenuhi:

\begin{lstlisting}[language=Pascal, caption={Input validasi dengan while (Pascal)}]
program ValidasiInput;
var
  angka: integer;
begin
  angka := -1;
  while angka < 0 do begin
    Write('Masukkan angka positif: ');
    Readln(angka);
    if angka < 0 then
      Writeln('Angka harus positif!');
  end;
  Writeln('Angka valid: ', angka);
end.
\end{lstlisting}

Contoh C berikut memanfaatkan \texttt{while} untuk count digit dalam sebuah integer dengan cara repeatedly membagi angka tersebut dengan 10:

\begin{lstlisting}[language=C, caption={Hitung digit dengan while (C)}]
#include <stdio.h>
int main(void) {
  int n, digit = 0;
  printf("Masukkan angka: ");
  scanf("%d", &n);
  
  int temp = n;
  while (temp != 0) {
    temp /= 10;
    digit++;
  }
  printf("Jumlah digit: %d\n", digit);
  return 0;
}
\end{lstlisting}

Contoh berikut menunjukkan bagaimana membaca data secara continuous hingga EOF (end-of-file) tercapai—pattern ini sangat useful untuk batch data processing:

\begin{lstlisting}[language=Pascal, caption={Baca hingga EOF (Pascal)}]
program ReadUntilEOF;
var
  x: integer;
begin
  while not EOF do begin
    Readln(x);
    Writeln('Baca: ', x);
  end;
end.
\end{lstlisting}

Program C++ berikut mengimplementasikan primality test menggunakan \texttt{while} loop, dengan mencoba membagi angka target dengan semua potential divisors:

\begin{lstlisting}[language=C++, caption={Hitung bilangan prima dengan while (C++)}]
#include <iostream>
using namespace std;

int main() {
  int n;
  cout << "Masukkan angka: ";
  cin >> n;
  
  int pembagi = 2;
  bool prima = (n > 1);
  
  while (pembagi * pembagi <= n && prima) {
    if (n % pembagi == 0)
      prima = false;
    pembagi++;
  }
  
  if (prima)
    cout << n << " adalah bilangan prima\n";
  else
    cout << n << " bukan bilangan prima\n";
}
\end{lstlisting}

\subsection{Contoh Loop \texttt{repeat-until} / \texttt{do-while}}

Program menu berikut memanfaatkan \texttt{repeat-until} untuk guarantee bahwa menu akan ditampilkan at least sekali, dan loop continues hingga user memutuskan untuk exit:

\begin{lstlisting}[language=Pascal, caption={Menu dengan repeat-until (Pascal)}]
program MenuLoop;
var
  pilihan: integer;
begin
  repeat
    Writeln('=== Menu ===');
    Writeln('1. Opsi A');
    Writeln('2. Opsi B');
    Writeln('0. Keluar');
    Write('Pilih: ');
    Readln(pilihan);
    
    case pilihan of
      1: Writeln('Anda pilih A');
      2: Writeln('Anda pilih B');
      0: Writeln('Keluar...');
    else
      Writeln('Pilihan tidak valid');
    end;
  until pilihan = 0;
end.
\end{lstlisting}

Dalam C, konstruksi \texttt{do-while} menjamin bahwa code block akan executed minimal satu kali sebelum condition checking dilakukan. Program berikut memproses input angka dan menanyakan apakah user ingin repeat:

\begin{lstlisting}[language=C, caption={Input ulang dengan do-while (C)}]
#include <stdio.h>
int main(void) {
  int angka;
  char lagi;
  
  do {
    printf("Masukkan angka: ");
    scanf("%d", &angka);
    printf("Kuadrat: %d\n", angka * angka);
    
    printf("Ulangi? (y/n): ");
    scanf(" %c", &lagi);
  } while (lagi == 'y' || lagi == 'Y');
  
  printf("Selesai.\n");
  return 0;
}
\end{lstlisting}

Program simple calculator berikut mengilustrasikan penggunaan \texttt{do-while} untuk repetitive menu, dengan combining loop structure dan \texttt{switch} branching:

\begin{lstlisting}[language=C++, caption={Validasi input dengan do-while (C++)}]
#include <iostream>
using namespace std;

int main() {
  int pilihan;
  
  do {
    cout << "\n=== Kalkulator Sederhana ===\n";
    cout << "1. Tambah\n";
    cout << "2. Kurang\n";
    cout << "3. Kali\n";
    cout << "4. Bagi\n";
    cout << "0. Keluar\n";
    cout << "Pilih operasi: ";
    cin >> pilihan;
    
    if (pilihan >= 1 && pilihan <= 4) {
      int a, b;
      cout << "Angka 1: "; cin >> a;
      cout << "Angka 2: "; cin >> b;
      
      switch(pilihan) {
        case 1: cout << "Hasil: " << a + b << "\n"; break;
        case 2: cout << "Hasil: " << a - b << "\n"; break;
        case 3: cout << "Hasil: " << a * b << "\n"; break;
        case 4: 
          if (b != 0) cout << "Hasil: " << (double)a / b << "\n";
          else cout << "Error: pembagi nol\n";
          break;
      }
    }
  } while (pilihan != 0);
  
  cout << "Terima kasih!\n";
}
\end{lstlisting}

Perhatian khusus harus diberikan pada \emph{off-by-one errors}—bug yang sangat umum dalam loop. Selalu gunakan boundary conditions yang eksplisit dan berikan nama variable yang deskriptif untuk loop counters.

\subsection{Pola Umum dan Anti-Pattern}
\begin{itemize}
  \item \textbf{Sentinel loop pattern}: Read data terlebih dahulu, evaluate condition, baru process—hindari code duplication dengan struktur yang well-designed.
  \item \textbf{Empty loop body is dangerous}: Jangan pernah menulis \texttt{while(...);}—pastikan ada loop body yang jelas atau minimal comment yang menjelaskan intentionality.
  \item \textbf{Mutating collection during iteration}: Di C++, be extremely careful ketika removing elements dari \texttt{vector} saat menggunakan \texttt{for-range} loop; lebih aman gunakan index-based atau iterator yang appropriate.
  \item \textbf{Counter overflow risk}: Pilih data type yang cukup besar untuk menampung jumlah iterasi yang diharapkan—jangan sampai counter overflow.
\end{itemize}

\section{Perulangan Bersarang (Nested Loop)}
Nested loop terjadi ketika kita menempatkan satu loop di dalam loop yang lain. Karakteristik utamanya: outer loop executes once, sementara inner loop runs completely untuk setiap single iteration dari outer loop. Pattern ini sangat common digunakan untuk processing multidimensional data structures seperti matrices, atau untuk generating combinations dan permutations.

\subsection{Diagram Nested Loop}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.4cm, >=Stealth]
    \tikzstyle{b}=[rectangle, draw, rounded corners, align=center, minimum width=2.6cm, minimum height=0.9cm]
    \node[b] (start) {Mulai};
    \node[b, below=of start] (outer) {Loop Luar};
    \node[b, below=of outer] (inner) {Loop Dalam};
    \node[b, below=of inner] (body) {Proses};
    \node[b, below=of body] (end) {Selesai};
    \draw[->] (start) -- (outer);
    \draw[->] (outer) -- (inner);
    \draw[->] (inner) -- (body);
    \draw[->] (body.east) -- +(1.5,0) |- (inner);
    \draw[->] (inner.west) -- +(-1.5,0) |- (outer);
    \draw[->] (outer.east) -- +(2.5,0) |- (end);
  \end{tikzpicture}
  \caption{Skema nested loop: loop dalam dieksekusi penuh untuk setiap iterasi loop luar}
\end{figure}

\subsection{Contoh Nested Loop}

Program-program berikut menggunakan double nested loops untuk generate star triangle pattern. Outer loop controls berapa banyak rows, sedangkan inner loop determines jumlah stars per row:

\begin{lstlisting}[language=Pascal, caption={Pola segitiga dengan nested loop (Pascal)}]
program PolaBintang;
var
  i, j, tinggi: integer;
begin
  Write('Masukkan tinggi segitiga: ');
  Readln(tinggi);
  
  for i := 1 to tinggi do begin
    for j := 1 to i do
      Write('* ');
    Writeln;
  end;
end.
\end{lstlisting}

Contoh C berikut generates multiplication table dengan memanfaatkan nested loops untuk iterate across rows dan columns:

\begin{lstlisting}[language=C, caption={Tabel perkalian dengan nested loop (C)}]
#include <stdio.h>
int main(void) {
  int baris = 5, kolom = 5;
  
  printf("Tabel Perkalian %dx%d:\n", baris, kolom);
  for (int i = 1; i <= baris; ++i) {
    for (int j = 1; j <= kolom; ++j) {
      printf("%4d", i * j);
    }
    printf("\n");
  }
  return 0;
}
\end{lstlisting}

Implementasi C++ yang equivalent untuk creating triangle pattern menggunakan nested loop structure:

\begin{lstlisting}[language=C++, caption={Pola bintang dengan nested loop (C++)}]
#include <iostream>
using namespace std;

int main() {
  int tinggi;
  cout << "Masukkan tinggi segitiga: ";
  cin >> tinggi;
  
  cout << "Pola segitiga:\n";
  for (int i = 1; i <= tinggi; ++i) {
    for (int j = 1; j <= i; ++j) {
      cout << "* ";
    }
    cout << "\n";
  }
}
\end{lstlisting}

Dalam nested loop, time complexity adalah product dari iterations di outer dan inner loop. Ketika nesting level mencapai 3 atau lebih, efficiency harus dipertimbangkan dengan serius—especially untuk large datasets. Evaluasi apakah ada alternative algorithms atau optimization strategies yang bisa diterapkan untuk improve performance.

\section{Penggunaan \texttt{break}, \texttt{continue}}
Statement \texttt{break} terminates loop secara complete dan mengalihkan control ke statement setelah loop. Sementara \texttt{continue} skips sisa current iteration dan immediately jumps ke iteration berikutnya. Gunakan kedua control statements ini dengan bijak—excessive use of \texttt{break} atau \texttt{continue} dapat membuat control flow sulit dipahami dan di-maintain \parencite{gnu-c-manual,cpp-reference}.

\subsection{Contoh \texttt{break} dan \texttt{continue}}

Program-program berikut mengilustrasikan bagaimana \texttt{continue} digunakan untuk skip specific iterations dan \texttt{break} untuk early termination dari loop:

\begin{lstlisting}[language=Pascal, caption={break dan continue di Pascal}]
program BreakContinue;
var
  i: integer;
begin
  { Continue: lewati bilangan ganjil }
  for i := 1 to 10 do begin
    if i mod 2 = 1 then
      continue;
    Writeln(i);  { hanya cetak genap }
  end;
  
  { Break: hentikan loop saat menemukan kondisi }
  i := 0;
  while true do begin
    i := i + 1;
    if i > 5 then
      break;
    Writeln('Iterasi: ', i);
  end;
end.
\end{lstlisting}

Dalam C, contoh berikut demonstrates how \texttt{continue} skips odd numbers dan \texttt{break} limits processing, termasuk aplikasinya dalam nested loop scenarios:

\begin{lstlisting}[language=C, caption={break dan continue di C}]
#include <stdio.h>
int main(void) {
  // Continue: cetak bilangan genap saja
  for (int i = 0; i < 100; ++i) {
    if (i % 2 == 1)
      continue;  // lewati bilangan ganjil
    if (i > 10)
      break;     // batasi proses
    printf("%d\n", i);
  }
  
  // Break pada nested loop: keluar dari loop dalam
  for (int i = 0; i < 5; ++i) {
    for (int j = 0; j < 5; ++j) {
      if (i * j > 6)
        break;  // keluar dari loop j
      printf("(%d,%d) ", i, j);
    }
    printf("\n");
  }
  return 0;
}
\end{lstlisting}

Program C++ berikut shows praktik penggunaan \texttt{break} untuk stop searching immediately ketika target element sudah ditemukan:

\begin{lstlisting}[language=C++, caption={break saat menemukan kondisi (C++)}]
#include <iostream>
using namespace std;

int main() {
  int n;
  cout << "Masukkan batas: ";
  cin >> n;
  
  cout << "Bilangan kelipatan 7:\n";
  for (int i = 1; i <= n; ++i) {
    if (i % 7 == 0) {
      cout << "Ditemukan: " << i << "\n";
      cout << "Berhenti di kelipatan 7 pertama\n";
      break;  // keluar loop setelah ditemukan
    }
    cout << i << " ";
  }
  cout << "\n";
}
\end{lstlisting}

Untuk menghindari excessive \texttt{break} atau \texttt{continue} statements, consider extracting complex predicates ke separate functions. Perlu diingat: dalam nested loops, \texttt{break} hanya exit dari innermost loop saja. Jika Anda perlu keluar dari multiple nested loops sekaligus, gunakan boolean flag atau labeled breaks (di bahasa yang support feature tersebut). Di C++, ensure iterators remain valid saat early exit dilakukan.
\section{Rangkuman Materi}
\begin{itemize}
  \item Kita telah mempelajari berbagai bentuk loop structures dan kapan menggunakan masing-masing: \texttt{while} untuk unknown iterations, \texttt{do-while}/\texttt{repeat-until} untuk minimal one execution, \texttt{for} untuk bounded iterations, dan range-based for (C++11+) untuk modern collections.
  \item Flowchart diagrams telah disajikan untuk visualisasi, common patterns seperti sentinel loops dijelaskan, serta anti-patterns yang harus dihindari (empty loop bodies, collection mutation during iteration, counter overflow risks).
  \item Praktik I/O dalam context of loops dibahas, termasuk input validation patterns dan wise usage dari \texttt{break}/\texttt{continue} control statements.
  \item Nested loop structures untuk pattern generation dan matrix processing telah dipelajari, lengkap dengan pemahaman tentang time complexity implications.
  \item Contoh-contoh comprehensive code tersedia untuk setiap loop form across ketiga bahasa: Pascal, C, dan C++.
\end{itemize}
\end{document}
