\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Record dan Struct}

\section*{Tujuan Praktikum}
Setelah menyelesaikan praktikum ini, mahasiswa diharapkan mampu:
\begin{itemize}
  \item Memahami konsep record/struct sebagai tipe data terstruktur heterogen
  \item Mendeklarasikan dan mendefinisikan record (Pascal) dan struct (C/C++)
  \item Mengakses dan memodifikasi field/member dari record/struct
  \item Membuat array of record/struct untuk menyimpan data tabular
  \item Memahami nested record/struct untuk struktur data kompleks
  \item Menggunakan typedef untuk menyederhanakan deklarasi struct
  \item Membuat program manajemen data sederhana menggunakan record/struct
\end{itemize}

\section{Pengantar Record/Struct}

\subsection{Konsep Dasar}
Record (Pascal) atau Struct (C/C++) adalah tipe data terstruktur yang memungkinkan pengelompokan beberapa variabel dengan tipe data berbeda di bawah satu nama. Berbeda dengan array yang menyimpan elemen bertipe sama, record/struct dapat menyimpan data heterogen yang saling terkait \parencite{pascal-structs,c-struct,cpp-struct-class,duniailkom-struct-c,tutorialspoint-c-structures}.

\textbf{Keuntungan menggunakan record/struct:}
\begin{itemize}
  \item \textbf{Organisasi data:} Mengelompokkan data terkait dalam satu entitas
  \item \textbf{Keterbacaan kode:} Nama struct yang deskriptif membuat kode lebih mudah dipahami
  \item \textbf{Modularitas:} Mengurangi jumlah parameter fungsi dengan mengirim satu struct
  \item \textbf{Pemeliharaan:} Perubahan struktur data terpusat di satu tempat
  \item \textbf{Reusabilitas:} Definisi struct dapat digunakan di berbagai bagian program
\end{itemize}

\subsection{Kapan Menggunakan Record/Struct}

Gunakan record/struct ketika:
\begin{itemize}
  \item Merepresentasikan entitas dunia nyata (mahasiswa, buku, produk, dll)
  \item Mengelompokkan data terkait yang sering dioperasikan bersama
  \item Membangun struktur data kompleks (linked list, tree, graph)
  \item Menyederhanakan passing data antar fungsi
  \item Membuat tipe data custom untuk domain spesifik
\end{itemize}

\section{Deklarasi Record/Struct}

\subsection{Deklarasi di Pascal}

Pascal menggunakan kata kunci \texttt{record} dengan sintaks yang jelas untuk mendefinisikan tipe data terstruktur.

Contoh berikut menunjukkan berbagai cara mendeklarasikan record di Pascal untuk merepresentasikan data mahasiswa, buku, koordinat, dan nilai:

\begin{lstlisting}[language=Pascal, caption={Deklarasi record di Pascal}]
type
  // Record sederhana untuk data mahasiswa
  TMahasiswa = record
    nama: string;
    nim: string;
    umur: integer;
    ipk: real;
  end;
  
  // Record dengan berbagai tipe data
  TBuku = record
    judul: string;
    pengarang: string;
    tahunTerbit: integer;
    harga: real;
    tersedia: boolean;
  end;
  
  // Record untuk koordinat
  TTitik = record
    x, y: real;  // Deklarasi multiple field
  end;
  
  // Record dengan array
  TNilai = record
    namaMatakuliah: string;
    sks: integer;
    nilai: array[1..10] of real;
  end;
\end{lstlisting}

\subsection{Deklarasi di C}

C menggunakan kata kunci \texttt{struct} dengan sintaks yang memungkinkan definisi inline atau terpisah.

Program berikut mendemonstrasikan berbagai cara mendeklarasikan struct di C, dengan dan tanpa typedef:

\begin{lstlisting}[language=C, caption={Deklarasi struct di C}]
// Definisi struct dengan typedef
typedef struct {
  char nama[50];
  char nim[15];
  int umur;
  float ipk;
} Mahasiswa;

// Definisi struct tanpa typedef (perlu kata struct)
struct Buku {
  char judul[100];
  char pengarang[50];
  int tahunTerbit;
  float harga;
  int tersedia;  // boolean di C (0 atau 1)
};

// Struct dengan tag name
struct Titik {
  double x;
  double y;
};

// Anonymous struct (jarang digunakan)
struct {
  int hari;
  int bulan;
  int tahun;
} tanggal;

// Struct dengan array
typedef struct {
  char namaMatakuliah[50];
  int sks;
  float nilai[10];
} Nilai;
\end{lstlisting}

\textbf{Perbedaan typedef dan non-typedef:}
\begin{itemize}
  \item Dengan \texttt{typedef}: langsung gunakan \texttt{Mahasiswa mhs;}
  \item Tanpa \texttt{typedef}: perlu \texttt{struct Buku buku1;}
  \item \texttt{typedef} membuat kode lebih ringkas dan konsisten
\end{itemize}

\subsection{Deklarasi di C++}

C++ memperlakukan \texttt{struct} dan \texttt{class} hampir sama, dengan default access yang berbeda.

Contoh berikut menunjukkan deklarasi struct di C++ dengan fitur tambahan seperti constructor, metode, dan operator overloading:

\begin{lstlisting}[language=C++, caption={Deklarasi struct di C++}]
#include <string>
#include <vector>

// Struct sederhana (default: public)
struct Mahasiswa {
  std::string nama;
  std::string nim;
  int umur;
  double ipk;
};

// Struct dengan constructor
struct Buku {
  std::string judul;
  std::string pengarang;
  int tahunTerbit;
  double harga;
  bool tersedia;
  
  // Constructor
  Buku() : tahunTerbit(0), harga(0.0), tersedia(false) {}
  
  Buku(const std::string& j, const std::string& p, 
       int t, double h) 
    : judul(j), pengarang(p), tahunTerbit(t), 
      harga(h), tersedia(true) {}
};

// Struct dengan metode
struct Titik {
  double x, y;
  
  // Metode untuk menghitung jarak dari origin
  double jarak() const {
    return std::sqrt(x*x + y*y);
  }
  
  // Metode untuk menggeser titik
  void geser(double dx, double dy) {
    x += dx;
    y += dy;
  }
};

// Struct dengan operator overloading
struct Kompleks {
  double real, imag;
  
  Kompleks operator+(const Kompleks& other) const {
    return {real + other.real, imag + other.imag};
  }
};
\end{lstlisting}

\section{Inisialisasi dan Pengisian Data}

\subsection{Inisialisasi di Pascal}

Program berikut mendemonstrasikan cara mengisi field record di Pascal, termasuk penggunaan \texttt{with} statement:

\begin{lstlisting}[language=Pascal, caption={Inisialisasi record di Pascal}]
var
  mhs1, mhs2: TMahasiswa;
  buku: TBuku;
begin
  // Pengisian field satu per satu
  mhs1.nama := 'John Doe';
  mhs1.nim := '1234567890';
  mhs1.umur := 20;
  mhs1.ipk := 3.75;
  
  // Pengisian dengan with statement
  with mhs2 do
  begin
    nama := 'Jane Smith';
    nim := '0987654321';
    umur := 21;
    ipk := 3.85;
  end;
  
  // Pengisian partial
  buku.judul := 'Algoritma Pemrograman';
  buku.pengarang := 'Prof. Ahmad';
  buku.tahunTerbit := 2023;
  // Field lain akan berisi nilai garbage jika tidak diisi
end.
\end{lstlisting}

\textbf{Catatan \texttt{with} statement:}
\begin{itemize}
  \item Mengurangi repetisi nama record
  \item Hati-hati dengan nested \texttt{with} -- bisa membingungkan
  \item Pastikan nama field tidak ambigu dengan variabel lokal
\end{itemize}

\subsection{Inisialisasi di C}

Contoh berikut menunjukkan berbagai cara inisialisasi struct di C, dari designated initializers hingga assignment antar struct:

\begin{lstlisting}[language=C, caption={Inisialisasi struct di C}]
#include <string.h>
#include <stdio.h>

int main() {
  // Inisialisasi saat deklarasi (designated initializers C99)
  Mahasiswa mhs1 = {
    .nama = "John Doe",
    .nim = "1234567890",
    .umur = 20,
    .ipk = 3.75
  };
  
  // Inisialisasi berurutan (older C style)
  Mahasiswa mhs2 = {"Jane Smith", "0987654321", 21, 3.85};
  
  // Inisialisasi partial (sisanya diisi 0)
  Mahasiswa mhs3 = {.nama = "Bob Lee"};
  
  // Zero initialization
  Mahasiswa mhs4 = {0};  // Semua field diisi 0
  
  // Pengisian setelah deklarasi
  Mahasiswa mhs5;
  strcpy(mhs5.nama, "Alice Wong");
  strcpy(mhs5.nim, "1122334455");
  mhs5.umur = 19;
  mhs5.ipk = 3.92;
  
  // Assignment antar struct (memberwise copy)
  Mahasiswa mhs6 = mhs1;  // Copy semua field
  
  printf("Mahasiswa 1: %s, NIM: %s, IPK: %.2f\n", 
         mhs1.nama, mhs1.nim, mhs1.ipk);
  
  return 0;
}
\end{lstlisting}

\textbf{Poin penting:}
\begin{itemize}
  \item Designated initializers (C99+) lebih jelas dan aman
  \item Gunakan \texttt{strcpy()} untuk field string, bukan assignment langsung
  \item Assignment antar struct melakukan shallow copy
  \item Hati-hati dengan uninitialized fields (nilai garbage)
\end{itemize}

\subsection{Inisialisasi di C++}

Program C++ berikut mendemonstrasikan berbagai cara inisialisasi struct termasuk uniform initialization, designated initializers (C++20), dan move semantics:

\begin{lstlisting}[language=C++, caption={Inisialisasi struct di C++}]
#include <iostream>
#include <string>

int main() {
  // Uniform initialization (C++11)
  Mahasiswa mhs1{"John Doe", "1234567890", 20, 3.75};
  
  // Designated initializers (C++20)
  Mahasiswa mhs2{
    .nama = "Jane Smith",
    .nim = "0987654321",
    .umur = 21,
    .ipk = 3.85
  };
  
  // Default initialization (memanggil default constructor)
  Mahasiswa mhs3;
  
  // Partial initialization
  Mahasiswa mhs4{};  // Value initialization (fields diisi default)
  
  // Pengisian setelah deklarasi
  Mahasiswa mhs5;
  mhs5.nama = "Bob Lee";
  mhs5.nim = "1122334455";
  mhs5.umur = 19;
  mhs5.ipk = 3.92;
  
  // Copy construction
  Mahasiswa mhs6 = mhs1;
  
  // Move construction (C++11)
  Mahasiswa mhs7 = std::move(mhs1);
  
  // Menggunakan constructor (jika didefinisikan)
  Buku buku1("Algoritma", "Prof. Ahmad", 2023, 150000);
  
  std::cout << "Mahasiswa 1: " << mhs2.nama 
            << ", IPK: " << mhs2.ipk << "\n";
  
  return 0;
}
\end{lstlisting}

\section{Akses dan Manipulasi Data}

\subsection{Akses Field}

Program berikut menunjukkan cara mengakses dan memodifikasi field record di Pascal:

\begin{lstlisting}[language=Pascal, caption={Akses field di Pascal}]
var
  mhs: TMahasiswa;
  nilai: real;
begin
  // Akses untuk membaca
  Writeln('Nama: ', mhs.nama);
  nilai := mhs.ipk;
  
  // Akses untuk menulis
  mhs.umur := mhs.umur + 1;  // Birthday!
  mhs.ipk := (mhs.ipk + 4.0) / 2;  // Update IPK
  
  // Menggunakan with untuk multiple access
  with mhs do
  begin
    Writeln('Data Mahasiswa:');
    Writeln('Nama: ', nama);
    Writeln('NIM: ', nim);
    Writeln('Umur: ', umur);
    Writeln('IPK: ', ipk:0:2);
  end;
end.
\end{lstlisting}

Di C, akses field menggunakan operator dot untuk membaca dan mengubah nilai:

\begin{lstlisting}[language=C, caption={Akses field di C}]
#include <stdio.h>

int main() {
  Mahasiswa mhs = {"John Doe", "123", 20, 3.5};
  
  // Akses untuk membaca
  printf("Nama: %s\n", mhs.nama);
  printf("NIM: %s\n", mhs.nim);
  printf("Umur: %d tahun\n", mhs.umur);
  printf("IPK: %.2f\n", mhs.ipk);
  
  // Akses untuk menulis/mengubah
  mhs.umur++;  // Increment umur
  mhs.ipk = (mhs.ipk + 3.8) / 2.0;  // Update IPK
  
  // Tampilkan setelah perubahan
  printf("\n=== Setelah Update ===\n");
  printf("Umur: %d tahun\n", mhs.umur);
  printf("IPK: %.2f\n", mhs.ipk);
  
  return 0;
}
\end{lstlisting}

Versi C++ yang serupa dengan stream I/O:

\begin{lstlisting}[language=C++, caption={Akses field di C++}]
#include <iostream>
using namespace std;

int main() {
  Mahasiswa mhs{"John Doe", "123", 20, 3.5};
  
  // Akses untuk membaca
  cout << "=== Data Mahasiswa ===\n";
  cout << "Nama: " << mhs.nama << "\n";
  cout << "NIM: " << mhs.nim << "\n";
  cout << "Umur: " << mhs.umur << " tahun\n";
  cout << "IPK: " << mhs.ipk << "\n";
  
  // Akses untuk menulis/mengubah
  mhs.umur++;
  mhs.ipk = (mhs.ipk + 3.8) / 2.0;
  
  // Tampilkan setelah perubahan
  cout << "\n=== Setelah Update ===\n";
  cout << "Umur: " << mhs.umur << " tahun\n";
  cout << "IPK: " << mhs.ipk << "\n";
  
  return 0;
}
\end{lstlisting}

\section{Array of Struct}

Array of struct sangat berguna untuk menyimpan koleksi entitas dengan struktur yang sama.

\subsection{Array of Struct di Pascal}

Program berikut mendemonstrasikan penggunaan array of struct untuk menyimpan data beberapa mahasiswa dan menghitung statistik rata-rata IPK:

\begin{lstlisting}[language=Pascal, caption={Array of struct di Pascal}]
const
  MAX_MHS = 100;

type
  TArrayMahasiswa = array[1..MAX_MHS] of TMahasiswa;

var
  daftarMhs: TArrayMahasiswa;
  jumlahMhs: integer;
  i: integer;
  totalIPK, rataIPK: real;

begin
  jumlahMhs := 3;
  
  // Isi data mahasiswa
  daftarMhs[1].nama := 'John Doe';
  daftarMhs[1].nim := '001';
  daftarMhs[1].umur := 20;
  daftarMhs[1].ipk := 3.75;
  
  daftarMhs[2].nama := 'Jane Smith';
  daftarMhs[2].nim := '002';
  daftarMhs[2].umur := 21;
  daftarMhs[2].ipk := 3.85;
  
  daftarMhs[3].nama := 'Bob Lee';
  daftarMhs[3].nim := '003';
  daftarMhs[3].umur := 19;
  daftarMhs[3].ipk := 3.92;
  
  // Tampilkan semua mahasiswa
  Writeln('=== Daftar Mahasiswa ===');
  for i := 1 to jumlahMhs do
  begin
    Writeln('Mahasiswa ', i);
    Writeln('Nama: ', daftarMhs[i].nama);
    Writeln('NIM: ', daftarMhs[i].nim);
    Writeln('IPK: ', daftarMhs[i].ipk:0:2);
    Writeln;
  end;
  
  // Hitung rata-rata IPK
  totalIPK := 0;
  for i := 1 to jumlahMhs do
    totalIPK := totalIPK + daftarMhs[i].ipk;
  rataIPK := totalIPK / jumlahMhs;
  Writeln('Rata-rata IPK: ', rataIPK:0:2);
end.
\end{lstlisting}

\subsection{Array of Struct di C}

Contoh C berikut mengelola array mahasiswa, mengisi data, dan menghitung rata-rata IPK:

\begin{lstlisting}[language=C, caption={Array of struct di C}]
#include <stdio.h>
#include <string.h>

#define MAX_MHS 100

int main() {
  Mahasiswa daftarMhs[MAX_MHS];
  int jumlahMhs = 3;
  
  // Isi data mahasiswa
  strcpy(daftarMhs[0].nama, "John Doe");
  strcpy(daftarMhs[0].nim, "001");
  daftarMhs[0].umur = 20;
  daftarMhs[0].ipk = 3.75;
  
  strcpy(daftarMhs[1].nama, "Jane Smith");
  strcpy(daftarMhs[1].nim, "002");
  daftarMhs[1].umur = 21;
  daftarMhs[1].ipk = 3.85;
  
  strcpy(daftarMhs[2].nama, "Bob Lee");
  strcpy(daftarMhs[2].nim, "003");
  daftarMhs[2].umur = 19;
  daftarMhs[2].ipk = 3.92;
  
  // Tampilkan semua mahasiswa
  printf("=== Daftar Mahasiswa ===\n");
  for (int i = 0; i < jumlahMhs; i++) {
    printf("Mahasiswa %d\n", i + 1);
    printf("Nama: %s\n", daftarMhs[i].nama);
    printf("NIM: %s\n", daftarMhs[i].nim);
    printf("IPK: %.2f\n\n", daftarMhs[i].ipk);
  }
  
  // Hitung rata-rata IPK
  float totalIPK = 0;
  for (int i = 0; i < jumlahMhs; i++) {
    totalIPK += daftarMhs[i].ipk;
  }
  float rataIPK = totalIPK / jumlahMhs;
  printf("Rata-rata IPK: %.2f\n", rataIPK);
  
  return 0;
}
\end{lstlisting}

\subsection{Array of Struct di C++}

Program C++ berikut menggunakan \texttt{std::vector} untuk koleksi struct yang dinamis, dengan filtering dan sorting data:

\begin{lstlisting}[language=C++, caption={Array of struct dengan vector di C++}]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int main() {
  // Menggunakan std::vector (lebih fleksibel)
  std::vector<Mahasiswa> daftarMhs;
  
  // Menambah mahasiswa
  daftarMhs.push_back({"John Doe", "001", 20, 3.75});
  daftarMhs.push_back({"Jane Smith", "002", 21, 3.85});
  daftarMhs.push_back({"Bob Lee", "003", 19, 3.92});
  
  // Atau dengan emplace_back (lebih efisien)
  daftarMhs.emplace_back("Alice Wong", "004", 22, 3.88);
  
  // Tampilkan semua mahasiswa
  std::cout << "=== Daftar Mahasiswa ===\n";
  for (size_t i = 0; i < daftarMhs.size(); i++) {
    std::cout << "Mahasiswa " << (i + 1) << "\n";
    std::cout << "Nama: " << daftarMhs[i].nama << "\n";
    std::cout << "NIM: " << daftarMhs[i].nim << "\n";
    std::cout << "IPK: " << daftarMhs[i].ipk << "\n\n";
  }
  
  // Range-based for loop
  std::cout << "=== Mahasiswa dengan IPK > 3.8 ===\n";
  for (const auto& mhs : daftarMhs) {
    if (mhs.ipk > 3.8) {
      std::cout << mhs.nama << " - IPK: " << mhs.ipk << "\n";
    }
  }
  
  // Hitung rata-rata IPK menggunakan algorithm
  double totalIPK = 0;
  for (const auto& mhs : daftarMhs) {
    totalIPK += mhs.ipk;
  }
  double rataIPK = totalIPK / daftarMhs.size();
  std::cout << "\nRata-rata IPK: " << rataIPK << "\n";
  
  // Sorting berdasarkan IPK
  std::sort(daftarMhs.begin(), daftarMhs.end(),
    [](const Mahasiswa& a, const Mahasiswa& b) {
      return a.ipk > b.ipk;  // Descending
    });
  
  std::cout << "\n=== Mahasiswa Terbaik ===\n";
  std::cout << daftarMhs[0].nama << " - IPK: " 
            << daftarMhs[0].ipk << "\n";
  
  return 0;
}
\end{lstlisting}

\section{Nested Struct}

Struct dapat berisi struct lain sebagai field, memungkinkan representasi data hierarkis.

\subsection{Nested Struct di Pascal}

Program berikut mendemonstrasikan struct bersarang (nested struct) untuk merepresentasikan data mahasiswa dengan tanggal lahir dan alamat lengkap:

\begin{lstlisting}[language=Pascal, caption={Nested struct di Pascal}]
type
  TTanggal = record
    hari: 1..31;
    bulan: 1..12;
    tahun: integer;
  end;
  
  TAlamat = record
    jalan: string;
    kota: string;
    provinsi: string;
    kodePos: string;
  end;
  
  TMahasiswaLengkap = record
    nama: string;
    nim: string;
    tanggalLahir: TTanggal;
    alamat: TAlamat;
    ipk: real;
  end;

var
  mhs: TMahasiswaLengkap;

begin
  // Pengisian data
  mhs.nama := 'John Doe';
  mhs.nim := '1234567890';
  
  // Akses nested struct
  mhs.tanggalLahir.hari := 15;
  mhs.tanggalLahir.bulan := 8;
  mhs.tanggalLahir.tahun := 2000;
  
  mhs.alamat.jalan := 'Jl. Merdeka No. 10';
  mhs.alamat.kota := 'Jakarta';
  mhs.alamat.provinsi := 'DKI Jakarta';
  mhs.alamat.kodePos := '10110';
  
  mhs.ipk := 3.75;
  
  // Tampilkan data
  Writeln('Nama: ', mhs.nama);
  Writeln('Tanggal Lahir: ', mhs.tanggalLahir.hari, '/',
          mhs.tanggalLahir.bulan, '/', mhs.tanggalLahir.tahun);
  Writeln('Alamat: ', mhs.alamat.jalan);
  Writeln('Kota: ', mhs.alamat.kota);
end.
\end{lstlisting}

\subsection{Nested Struct di C}

\begin{lstlisting}[language=C, caption={Nested struct di C}]
#include <stdio.h>
#include <string.h>

typedef struct {
  int hari;
  int bulan;
  int tahun;
} Tanggal;

typedef struct {
  char jalan[100];
  char kota[50];
  char provinsi[50];
  char kodePos[10];
} Alamat;

typedef struct {
  char nama[50];
  char nim[15];
  Tanggal tanggalLahir;
  Alamat alamat;
  float ipk;
} MahasiswaLengkap;

void printTanggal(Tanggal t) {
  printf("%02d/%02d/%04d", t.hari, t.bulan, t.tahun);
}

void printMahasiswaLengkap(MahasiswaLengkap m) {
  printf("=== Data Mahasiswa Lengkap ===\n");
  printf("Nama: %s\n", m.nama);
  printf("NIM: %s\n", m.nim);
  printf("Tanggal Lahir: ");
  printTanggal(m.tanggalLahir);
  printf("\nAlamat: %s\n", m.alamat.jalan);
  printf("        %s, %s %s\n", m.alamat.kota, 
         m.alamat.provinsi, m.alamat.kodePos);
  printf("IPK: %.2f\n", m.ipk);
}

int main() {
  MahasiswaLengkap mhs;
  
  // Isi data
  strcpy(mhs.nama, "John Doe");
  strcpy(mhs.nim, "1234567890");
  
  mhs.tanggalLahir.hari = 15;
  mhs.tanggalLahir.bulan = 8;
  mhs.tanggalLahir.tahun = 2000;
  
  strcpy(mhs.alamat.jalan, "Jl. Merdeka No. 10");
  strcpy(mhs.alamat.kota, "Jakarta");
  strcpy(mhs.alamat.provinsi, "DKI Jakarta");
  strcpy(mhs.alamat.kodePos, "10110");
  
  mhs.ipk = 3.75;
  
  // Tampilkan
  printMahasiswaLengkap(mhs);
  
  return 0;
}
\end{lstlisting}

\subsection{Nested Struct di C++}

\begin{lstlisting}[language=C++, caption={Nested struct di C++}]
#include <iostream>
#include <string>
#include <iomanip>

struct Tanggal {
  int hari, bulan, tahun;
  
  std::string toString() const {
    return std::to_string(hari) + "/" + 
           std::to_string(bulan) + "/" + 
           std::to_string(tahun);
  }
};

struct Alamat {
  std::string jalan;
  std::string kota;
  std::string provinsi;
  std::string kodePos;
  
  std::string toStringLengkap() const {
    return jalan + "\n" + kota + ", " + provinsi + " " + kodePos;
  }
};

struct MahasiswaLengkap {
  std::string nama;
  std::string nim;
  Tanggal tanggalLahir;
  Alamat alamat;
  double ipk;
  
  void print() const {
    std::cout << "=== Data Mahasiswa Lengkap ===\n";
    std::cout << "Nama: " << nama << "\n";
    std::cout << "NIM: " << nim << "\n";
    std::cout << "Tanggal Lahir: " << tanggalLahir.toString() << "\n";
    std::cout << "Alamat:\n" << alamat.toStringLengkap() << "\n";
    std::cout << "IPK: " << std::fixed << std::setprecision(2) 
              << ipk << "\n";
  }
};

int main() {
  // Menggunakan designated initializers (C++20)
  MahasiswaLengkap mhs{
    .nama = "John Doe",
    .nim = "1234567890",
    .tanggalLahir = {15, 8, 2000},
    .alamat = {
      "Jl. Merdeka No. 10",
      "Jakarta",
      "DKI Jakarta",
      "10110"
    },
    .ipk = 3.75
  };
  
  mhs.print();
  
  // Akses nested fields
  std::cout << "\nKota: " << mhs.alamat.kota << "\n";
  std::cout << "Tahun lahir: " << mhs.tanggalLahir.tahun << "\n";
  
  return 0;
}
\end{lstlisting}

\paragraph{Catatan tentang Fungsi.} Pada Bab 10 nanti, Anda akan mempelajari cara membuat dan menggunakan fungsi untuk memproses struct. Fungsi memungkinkan kode yang lebih modular dan dapat digunakan kembali. Untuk saat ini, fokus pada pemahaman deklarasi, inisialisasi, dan akses field struct secara langsung.

\section{Contoh Program Lengkap dengan Array of Struct}

\subsection{Program Perpustakaan Sederhana (C)}

Program lengkap berikut mengimplementasikan sistem perpustakaan sederhana dengan array of struct untuk menyimpan data buku dan mengelola status peminjaman:

\begin{lstlisting}[language=C, caption={Program perpustakaan sederhana di C}]
#include <stdio.h>
#include <string.h>

#define MAX_BUKU 10

typedef struct {
  char judul[100];
  char pengarang[50];
  int tahunTerbit;
  int tersedia;  // 1 = tersedia, 0 = dipinjam
} Buku;

int main() {
  Buku perpustakaan[MAX_BUKU];
  int jumlahBuku = 0;
  int i;
  
  // Tambah buku pertama
  strcpy(perpustakaan[jumlahBuku].judul, "Algoritma dan Pemrograman");
  strcpy(perpustakaan[jumlahBuku].pengarang, "Prof. Ahmad");
  perpustakaan[jumlahBuku].tahunTerbit = 2023;
  perpustakaan[jumlahBuku].tersedia = 1;
  jumlahBuku++;
  
  // Tambah buku kedua
  strcpy(perpustakaan[jumlahBuku].judul, "Struktur Data");
  strcpy(perpustakaan[jumlahBuku].pengarang, "Dr. Budi");
  perpustakaan[jumlahBuku].tahunTerbit = 2022;
  perpustakaan[jumlahBuku].tersedia = 1;
  jumlahBuku++;
  
  // Tambah buku ketiga
  strcpy(perpustakaan[jumlahBuku].judul, "Basis Data");
  strcpy(perpustakaan[jumlahBuku].pengarang, "Prof. Citra");
  perpustakaan[jumlahBuku].tahunTerbit = 2021;
  perpustakaan[jumlahBuku].tersedia = 1;
  jumlahBuku++;
  
  // Tampilkan semua buku
  printf("\n=== Daftar Buku Perpustakaan ===\n");
  printf("Total buku: %d\n", jumlahBuku);
  for (i = 0; i < jumlahBuku; i++) {
    printf("\n[%d] %s\n", i + 1, perpustakaan[i].judul);
    printf("    Pengarang: %s\n", perpustakaan[i].pengarang);
    printf("    Tahun: %d\n", perpustakaan[i].tahunTerbit);
    printf("    Status: %s\n", 
           perpustakaan[i].tersedia ? "Tersedia" : "Dipinjam");
  }
  
  // Pinjam buku pertama
  perpustakaan[0].tersedia = 0;
  printf("\nBuku '%s' berhasil dipinjam.\n", perpustakaan[0].judul);
  
  // Tampilkan status setelah peminjaman
  printf("\nStatus buku setelah peminjaman:\n");
  for (i = 0; i < jumlahBuku; i++) {
    printf("[%d] %s - %s\n", i + 1, perpustakaan[i].judul,
           perpustakaan[i].tersedia ? "Tersedia" : "Dipinjam");
  }
  
  return 0;
}
\end{lstlisting}

\subsection{Program Manajemen Mahasiswa (C++)}

Program C++ berikut mengelola data mahasiswa dengan array statis, menampilkan dalam format tabel, dan mencari mahasiswa dengan IPK tertinggi:

\begin{lstlisting}[language=C++, caption={Program manajemen mahasiswa sederhana di C++}]
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;

struct Mahasiswa {
  string nama;
  string nim;
  double ipk;
};

int main() {
  const int MAX_MHS = 10;
  Mahasiswa daftar[MAX_MHS];
  int jumlah = 0;
  
  // Tambah mahasiswa
  daftar[jumlah].nama = "John Doe";
  daftar[jumlah].nim = "001";
  daftar[jumlah].ipk = 3.75;
  jumlah++;
  
  daftar[jumlah].nama = "Jane Smith";
  daftar[jumlah].nim = "002";
  daftar[jumlah].ipk = 3.92;
  jumlah++;
  
  daftar[jumlah].nama = "Bob Lee";
  daftar[jumlah].nim = "003";
  daftar[jumlah].ipk = 3.65;
  jumlah++;
  
  // Tampilkan semua mahasiswa
  cout << "\n=== Daftar Mahasiswa ===\n";
  cout << left << setw(20) << "Nama" 
       << setw(10) << "NIM" 
       << setw(10) << "IPK" << "\n";
  cout << string(40, '-') << "\n";
  
  for (int i = 0; i < jumlah; i++) {
    cout << left << setw(20) << daftar[i].nama
         << setw(10) << daftar[i].nim
         << fixed << setprecision(2)
         << setw(10) << daftar[i].ipk << "\n";
  }
  
  // Cari mahasiswa dengan IPK tertinggi
  int indexTerbaik = 0;
  for (int i = 1; i < jumlah; i++) {
    if (daftar[i].ipk > daftar[indexTerbaik].ipk) {
      indexTerbaik = i;
    }
  }
  
  cout << "\n=== Mahasiswa Terbaik ===\n";
  cout << "Nama: " << daftar[indexTerbaik].nama << "\n";
  cout << "NIM: " << daftar[indexTerbaik].nim << "\n";
  cout << "IPK: " << fixed << setprecision(2) 
       << daftar[indexTerbaik].ipk << "\n";
  
  return 0;
}
\end{lstlisting}

\section{Enumerasi (Enum)}

Enumerasi adalah tipe data yang terdiri dari sekumpulan konstanta bernama, berguna untuk merepresentasikan pilihan terbatas.

\subsection{Enum di Pascal}

Contoh berikut menunjukkan cara mendefinisikan dan menggunakan tipe enumerasi di Pascal untuk merepresentasikan pilihan terbatas:

\begin{lstlisting}[language=Pascal, caption={Enum di Pascal}]
type
  THari = (Senin, Selasa, Rabu, Kamis, Jumat, Sabtu, Minggu);
  TStatus = (Aktif, Nonaktif, Lulus, Drop);
  
  TMahasiswa = record
    nama: string;
    nim: string;
    status: TStatus;
  end;

var
  hari: THari;
  mhs: TMahasiswa;

begin
  hari := Senin;
  
  if hari = Senin then
    Writeln('Hari ini Senin');
  
  mhs.status := Aktif;
  
  case mhs.status of
    Aktif: Writeln('Mahasiswa aktif');
    Lulus: Writeln('Mahasiswa lulus');
    else Writeln('Status lain');
  end;
end.
\end{lstlisting}

\subsection{Enum di C}

Program C berikut mendemonstrasikan enum dengan fungsi helper untuk konversi nilai enum ke string yang dapat dibaca:

\begin{lstlisting}[language=C, caption={Enum di C}]
#include <stdio.h>

typedef enum {
  SENIN, SELASA, RABU, KAMIS, JUMAT, SABTU, MINGGU
} Hari;

typedef enum {
  AKTIF = 1,
  NONAKTIF = 0,
  LULUS = 2,
  DROP = 3
} Status;

typedef struct {
  char nama[50];
  char nim[15];
  Status status;
} Mahasiswa;

const char* namaHari(Hari h) {
  const char* hari[] = {
    "Senin", "Selasa", "Rabu", "Kamis",
    "Jumat", "Sabtu", "Minggu"
  };
  return hari[h];
}

const char* namaStatus(Status s) {
  switch(s) {
    case AKTIF: return "Aktif";
    case NONAKTIF: return "Nonaktif";
    case LULUS: return "Lulus";
    case DROP: return "Drop";
    default: return "Unknown";
  }
}

int main() {
  Hari hari = SENIN;
  printf("Hari ini: %s\n", namaHari(hari));
  
  Mahasiswa mhs = {"John", "001", AKTIF};
  printf("Status: %s\n", namaStatus(mhs.status));
  
  return 0;
}
\end{lstlisting}

\subsection{Enum di C++}

C++ menyediakan scoped enum (enum class) yang lebih type-safe dan tidak mengotori namespace global:

\begin{lstlisting}[language=C++, caption={Enum class di C++}]
#include <iostream>
#include <string>

// Unscoped enum (C-style, bisa implicit conversion)
enum Hari {
  Senin, Selasa, Rabu, Kamis, Jumat, Sabtu, Minggu
};

// Scoped enum (C++11, lebih aman)
enum class Status {
  Aktif,
  Nonaktif,
  Lulus,
  Drop
};

struct Mahasiswa {
  std::string nama;
  std::string nim;
  Status status;
};

std::string namaStatus(Status s) {
  switch(s) {
    case Status::Aktif: return "Aktif";
    case Status::Nonaktif: return "Nonaktif";
    case Status::Lulus: return "Lulus";
    case Status::Drop: return "Drop";
    default: return "Unknown";
  }
}

int main() {
  Hari hari = Senin;
  std::cout << "Hari: " << hari << "\n";  // Prints 0
  
  Mahasiswa mhs{"John", "001", Status::Aktif};
  std::cout << "Status: " << namaStatus(mhs.status) << "\n";
  
  // Enum class lebih aman - tidak bisa implicit conversion
  // int x = Status::Aktif;  // ERROR!
  // if (hari == Status::Aktif) {}  // ERROR! Type mismatch
  
  return 0;
}
\end{lstlisting}

\section{Best Practices dan Tips}

\subsection{Desain Struct yang Baik}

\begin{enumerate}
  \item \textbf{Nama yang deskriptif:} Gunakan nama yang jelas menggambarkan entitas
  \item \textbf{Kohesi tinggi:} Field dalam struct harus saling terkait
  \item \textbf{Ukuran wajar:} Struct terlalu besar pertimbangkan dipecah
  \item \textbf{Inisialisasi:} Selalu inisialisasi field untuk menghindari garbage value
  \item \textbf{Const-correctness:} Gunakan const untuk data yang tidak berubah
  \item \textbf{Dokumentasi:} Jelaskan purpose dan constraint setiap field
\end{enumerate}

\subsection{Memory Layout dan Padding}

\begin{lstlisting}[language=C, caption={Struct padding di C}]
#include <stdio.h>

// Struct dengan padding
struct BadLayout {
  char a;      // 1 byte + 3 bytes padding
  int b;       // 4 bytes
  char c;      // 1 byte + 3 bytes padding
  int d;       // 4 bytes
};  // Total: 16 bytes

// Struct dengan layout optimal
struct GoodLayout {
  int b;       // 4 bytes
  int d;       // 4 bytes
  char a;      // 1 byte
  char c;      // 1 byte + 2 bytes padding
};  // Total: 12 bytes

int main() {
  printf("BadLayout size: %zu\n", sizeof(struct BadLayout));
  printf("GoodLayout size: %zu\n", sizeof(struct GoodLayout));
  return 0;
}
\end{lstlisting}

\textbf{Tips mengoptimalkan struct:}
\begin{itemize}
  \item Kelompokkan field dengan tipe sama
  \item Urutkan dari terbesar ke terkecil
  \item Gunakan \texttt{\_\_attribute\_\_((packed))} atau \texttt{\#pragma pack} jika perlu
  \item Hati-hati dengan unaligned access (performance hit)
\end{itemize}

\subsection{Bit-field dan Representasi Kompak (C/C++)}
Bit-field dapat mengemas beberapa nilai kecil dalam satu kata memori, namun portabilitasnya terbatas (endianness, alignment, urutan bit implementasi) \parencite{c-bitfield,cpp-bitfield}.

\begin{lstlisting}[language=C, caption={Bit-field untuk flags (C)}]
struct Flags {
  unsigned ready:1;
  unsigned error:1;
  unsigned mode:2; // 0..3
  unsigned reserved:4;
};
\end{lstlisting}

Untuk portabilitas dan operasi bit yang eksplisit, pertimbangkan \texttt{std::bitset} di C++ \parencite{cpp-bitset}.

\subsection{Shallow vs Deep Copy; Resource Ownership}
Struct yang berisi pointer memerlukan perhatian khusus saat disalin. Di C++, gunakan aturan lima (atau tiga) untuk mengelola resource \parencite{cpp-special-member-functions}.

\begin{lstlisting}[language=C++, caption={Aturan lima untuk kepemilikan resource}]
struct BufferOwner {
  size_t n{};
  int* data{};

  BufferOwner(size_t size): n(size), data(new int[size]{}) {}
  ~BufferOwner() { delete[] data; }
  BufferOwner(const BufferOwner& other): n(other.n), data(new int[n]) {
    std::copy(other.data, other.data + n, data);
  }
  BufferOwner& operator=(const BufferOwner& other) {
    if (this != &other) {
      BufferOwner tmp(other);
      std::swap(n, tmp.n);
      std::swap(data, tmp.data);
    }
    return *this;
  }
  BufferOwner(BufferOwner&& other) noexcept: n(other.n), data(other.data) {
    other.n = 0; other.data = nullptr;
  }
  BufferOwner& operator=(BufferOwner&& other) noexcept {
    if (this != &other) {
      delete[] data;
      n = other.n; data = other.data;
      other.n = 0; other.data = nullptr;
    }
    return *this;
  }
};
\end{lstlisting}

Sebaliknya, gunakan \texttt{std::vector<int>} untuk menghindari pengelolaan manual.

\subsection{Serialisasi Biner dan Endianness}
Mempersingkat penyimpanan dengan menulis struct secara biner rentan terhadap perbedaan padding dan endianness \parencite{endianness-wiki}. Gunakan format yang terdefinisi (misal, tulis field per field) dan mode biner \parencite{c-fwrite,cpp-openmode-binary}.

\begin{lstlisting}[language=C, caption={Tulis baca biner per-field (C)}]
FILE* f = fopen("data.bin", "wb");
fwrite(&mhs.umur, sizeof mhs.umur, 1, f);
fwrite(&mhs.ipk,  sizeof mhs.ipk,  1, f);
// ... tulis panjang string lalu byte-nya ...
fclose(f);
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Mode biner di C++}]
#include <fstream>
std::ofstream out("data.bin", std::ios::binary);
out.write(reinterpret_cast<const char*>(&mhs.umur), sizeof mhs.umur);
// ...
\end{lstlisting}

\subsection{Kesalahan Umum}

\begin{enumerate}
  \item \textbf{Uninitialized fields:} Lupa menginisialisasi field
  \item \textbf{String handling di C:} Lupa null terminator atau buffer overflow
  \item \textbf{Shallow vs deep copy:} Pointer/reference di dalam struct
  \item \textbf{Struct comparison:} Tidak bisa menggunakan \texttt{==} di C (perlu memcmp)
  \item \textbf{Return large struct:} Inefficient return by value
  \item \textbf{Memory alignment:} Asumsi salah tentang layout memori
\end{enumerate}

\section{Rangkuman}

Record/Struct adalah tipe data terstruktur fundamental yang memungkinkan pengelompokan data heterogen menjadi satu entitas logis. Pemahaman yang baik tentang deklarasi, inisialisasi, dan manipulasi struct sangat penting untuk pemrograman yang efektif.

\subsection{Poin-Poin Penting}

\begin{itemize}
  \item Struct mengelompokkan data terkait dengan tipe berbeda
  \item Pascal menggunakan \texttt{record}, C/C++ menggunakan \texttt{struct}
  \item Akses field menggunakan operator dot (\texttt{.})
  \item Array of struct berguna untuk koleksi entitas
  \item Nested struct memungkinkan hierarki data
  \item Passing struct by reference/pointer lebih efisien
  \item Enum memperkaya struct dengan nilai terbatas yang jelas
  \item Memory padding memengaruhi ukuran struct
\end{itemize}

\subsection{Perbandingan Antar Bahasa}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Aspek} & \textbf{Pascal} & \textbf{C} & \textbf{C++} \\
\hline
Kata kunci & record & struct & struct/class \\
\hline
Constructor & Tidak & Tidak & Ya \\
\hline
Metode & Tidak & Tidak & Ya \\
\hline
Access control & Tidak & Tidak & Ya (public/private) \\
\hline
Operator overload & Tidak & Tidak & Ya \\
\hline
Inheritance & Tidak & Tidak & Ya \\
\hline
\end{tabular}
\caption{Perbandingan struct/record di Pascal, C, dan C++}
\end{table}

Struct/record adalah building blocks untuk struktur data yang lebih kompleks seperti linked list, tree, dan graph. Penguasaan yang baik akan memudahkan pembelajaran konsep pemrograman lanjutan!

\section{Rangkuman Materi}
\begin{itemize}
  \item Deklarasi dan penggunaan record/struct lintas Pascal/C/C++; enum (unscoped vs scoped).
  \item Bit-field: penggunaan dan keterbatasan portabilitas; alternatif \texttt{std::bitset}.
  \item Shallow vs deep copy; aturan lima (constructor/assignment/move/destructor) untuk kepemilikan resource.
  \item Serialisasi biner: perhatian pada padding, endianness, dan mode biner.
  \item Layout memori dan padding; urutan field yang lebih optimal dan contoh pengukuran ukuran/offset.
\end{itemize}

\end{document}
