\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Tipe Data, Variabel, Input / Output (Pascal, C, C++)}
\section{Tipe Data Dasar}
Tipe data menentukan domain nilai dan operasi yang sah, sehingga berpengaruh langsung terhadap ketepatan perhitungan dan penggunaan memori. Pascal menyediakan tipe skalar seperti \texttt{integer}, \texttt{real}, \texttt{char}, dan \texttt{boolean}, sedangkan C/C++ memiliki \texttt{int}, \texttt{double}, \texttt{char}, dan tipe logika modern seperti \texttt{bool}. Pemahaman ukuran dan rentang nilai pada tiap platform penting untuk mencegah overflow dan kesalahan representasi \parencite{pascal-tutorial-wikibooks,iso-c-draft-n1570,cpp-reference}.

Penggunaan tipe yang tepat membantu menyatakan maksud program secara jelas dan memudahkan optimasi oleh kompilator. Pada C/C++, kualifikator seperti \texttt{signed/unsigned} serta \texttt{short/long} memengaruhi rentang dan kinerja, sedangkan pada Pascal rentang indeks yang eksplisit memperjelas invarian. Dokumentasi resmi menyediakan tabel korespondensi ukuran tipe serta ketentuan standar yang relevan \parencite{free-pascal-docs,iso-c-draft-n1570,cpp-reference}.

Representasi memori dan aturan konversi implisit perlu dipahami agar tidak terjadi kehilangan presisi. Misalnya, promosi integral dalam C dapat mengubah hasil evaluasi ekspresi ketika tipe berbeda dicampurkan. Prinsip konservatif adalah memperjelas konversi dengan eksplisit \emph{cast} hanya ketika benar-benar diperlukan \parencite{gnu-c-manual,cpp-reference}.

\section{Deklarasi \& Inisialisasi Variabel}
Deklarasi variabel menetapkan nama, tipe, dan cakupan sehingga kompilator dapat memeriksa ketepatan penggunaan. Inisialisasi awal penting untuk menghindari kondisi tak terdefinisi, terutama pada C yang tidak menginisialisasi variabel lokal secara otomatis. Pascal dan C++ menawarkan inisialisasi yang lebih ekspresif, termasuk inisialisasi terbraket pada C++ \parencite{pascal-tutorial-wikibooks,gnu-c-manual,cpp-reference}.

Disiplin penamaan yang konsisten meningkatkan keterbacaan dan memudahkan penelusuran data melalui program. Ketika lingkup variabel terlalu panjang, pecahlah fungsi menjadi unit yang lebih kecil agar invarian lebih mudah dipertahankan. Praktik baik lain meliputi penggunaan \texttt{const} untuk menyatakan nilai yang tidak boleh berubah dan preferensi imutabilitas saat memungkinkan.

Pada C/C++, pertimbangkan aturan durasi penyimpanan seperti otomatis, statik, dan dinamis untuk mengelola siklus hidup variabel. Deklarasi pada titik penggunaan (\emph{declare near use}) meminimalkan rentang hidup dan menurunkan kompleksitas. Pada Pascal, penempatan deklarasi yang jelas di bagian \texttt{var} tetap menyediakan struktur yang mudah diaudit \parencite{free-pascal-docs,gnu-c-manual}.

\section{Input / Output Dasar}
Masukan/keluaran dasar menyediakan sarana interaksi program dengan pengguna atau berkas. Pascal menggunakan \texttt{Read/Readln} dan \texttt{Write/Writeln} dengan dukungan format sederhana, sementara C memakai keluarga fungsi \texttt{scanf/printf} dan C++ memakai \texttt{std::cin/std::cout}. Perbedaan model pemformatan berpengaruh pada cara mengendalikan presisi, lebar bidang, dan penanganan spasi \parencite{w3pascal-io,gnu-c-manual,cplusplus-io}.

Keluaran kesalahan sebaiknya dipisahkan dari keluaran normal untuk memudahkan automasi dan pengujian. Pada C, gunakan \texttt{stderr} untuk pesan kesalahan dan pertimbangkan \texttt{snprintf} untuk mencegah luapan buffer. Pada C++, manfaatkan manipulator seperti \texttt{std::setw} dan \texttt{std::setprecision} untuk menghasilkan keluaran yang konsisten secara visual \parencite{gnu-c-manual,cpp-reference}.

Untuk masukan yang tangguh, pertimbangkan membaca baris teks lalu melakukan parsing eksplisit agar validasi lebih terkendali. Pada C/C++, menggabungkan \texttt{fgets}/\texttt{std::getline} dengan konversi numerik yang memeriksa kesalahan meningkatkan keandalan. Dokumentasi standar menguraikan spesifikasi lengkap format dan status stream untuk diagnosa \parencite{iso-c-draft-n1570,cpp-reference}.

\section{Konversi Tipe dan Operasi Terkait}
Konversi tipe dapat bersifat implisit atau eksplisit, dan keduanya memiliki konsekuensi terhadap presisi serta aturan evaluasi. Pada C, promosi aritmetika menstandarkan tipe operan sebelum evaluasi ekspresi; pada C++ konversi eksplisit seperti \texttt{static\_cast} memberikan niat yang lebih tegas. Pascal cenderung menolak pencampuran tipe yang ambigu sehingga mendorong penulisan konversi yang jelas \parencite{pascal-tutorial-wikibooks,gnu-c-manual,cpp-reference}.

Pertimbangkan biaya konversi pada jalur panas eksekusi, terutama untuk koleksi besar atau perhitungan numerik intensif. Teknik seperti mempersempit titik konversi dan menggunakan tipe target sejak awal dapat menurunkan beban runtime. Unit uji sangat membantu untuk memastikan kesetaraan numerik sebelum dan sesudah refaktor konversi.

Dalam konteks I/O, konversi format ke representasi internal dan sebaliknya harus diperlakukan sebagai batas kepercayaan data. Validasi masukan dan sanitasi karakter membantu mencegah perilaku tak terduga. Standar bahasa dan dokumentasi referensi menyediakan aturan formal serta contoh idiomatik \parencite{iso-c-draft-n1570,cpp-reference}.
\end{document}
