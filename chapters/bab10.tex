\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Alokasi Dinamis \& Pointer Lanjutan}
\section{Alokasi Memori Dinamis}
\subsection{Contoh C dan C++}
\begin{lstlisting}[language=C, caption={Pola cleanup bertahap di C}]
#include <stdlib.h>
int foo(size_t n){
  int rc = -1; int *a = NULL, *b = NULL;
  a = malloc(n*sizeof *a); if (!a) goto done;
  b = malloc(n*sizeof *b); if (!b) goto done;
  // ... gunakan a dan b ...
  rc = 0;
done:
  free(b); free(a); return rc;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={RAII dengan unique_ptr di C++}]
#include <memory>
int process(size_t n){
  auto buf = std::make_unique<int[]>(n);
  // ... gunakan buf ... otomatis dibebaskan saat keluar scope
  return 0;
}
\end{lstlisting}
Alokasi dinamis memungkinkan program memperoleh memori pada runtime untuk ukuran data yang tidak dapat diprediksi di awal. Di C, fungsi \texttt{malloc}/\texttt{calloc}/\texttt{realloc}/\texttt{free} menyediakan kontrol langsung atas siklus hidup memori. Di C++, operator \texttt{new}/\texttt{delete} dan penunjuk pintar seperti \texttt{std::unique\_ptr} mengenkapsulasi kepemilikan dan pembebasan otomatis \parencite{iso-c-draft-n1570,cpp-reference}.

Strategi pengalokasian harus menyatakan dengan jelas pemilik data dan jalur pembebasan untuk setiap cabang eksekusi. Gunakan \emph{RAII} pada C++ untuk menjamin pembebasan meski terjadi pengecualian. Pada C, pola goto cleanup dan blok \texttt{defer}-like (dengan makro) membantu menjaga konsistensi pembebasan sumber daya \parencite{gnu-c-manual}.

Pertimbangkan dampak fragmentasi memori dan biaya realokasi pada struktur yang sering berubah ukuran. Di C++, \texttt{std::vector} dan \texttt{std::string} mengelola pertumbuhan kapasitas, namun tetap butuh kewaspadaan pada invalidasi iterator saat re-alokasi.

\section{Pointer \& Dereferensi}
\subsection{Diagram Tata Letak Memori}
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \tikzstyle{blk}=[rectangle, draw, rounded corners, minimum width=1.8cm, minimum height=0.9cm]
    \node[blk] (p) {p: addr};
    \node[blk, right=of p] (buf0) {buf[0]};
    \node[blk, right=of buf0] (buf1) {buf[1]};
    \node[blk, right=of buf1] (buf2) {buf[2]};
    \draw[->] (p) -- (buf0);
  \end{tikzpicture}
  \caption{Pointer menunjuk ke awal buffer berurutan}
\end{figure}
Manipulasi pointer yang aman menuntut inisialisasi eksplisit, larangan penggunaan setelah dibebaskan (use-after-free), dan validasi sebelum dereferensi. Gunakan pengenal null yang konsisten dan pertimbangkan \texttt{nonnull} pada kontrak API. Di C++, preferensikan referensi ketika non-null dijamin agar niat lebih terlihat \parencite{gnu-c-manual,cpp-reference}.

Teknik seperti \emph{owner/raw pointer split} di C++ memisahkan peran pengelolaan dari akses non-kepemilikan. Untuk C, konvensi dokumenter tentang siapa yang bertanggung jawab membebaskan memori harus ditegakkan dengan uji dan tinjauan kode. Alat analisis statis dapat membantu mendeteksi kebocoran dan akses tidak valid.

\section{Pointer ke Array / Pointer ke Pointer}
\subsection{Contoh Alokasi 2D}
\begin{lstlisting}[language=C, caption={Matriks dinamis 2D di C (pointer ganda)}]
int **m = malloc(r*sizeof *m);
for (int i=0;i<r;++i) m[i] = malloc(c*sizeof *m[i]);
// ... gunakan m[i][j] ...
for (int i=0;i<r;++i) free(m[i]); free(m);
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={std::unique_ptr<T[]> untuk buffer 2D datar}]
#include <memory>
std::unique_ptr<int[]> buf = std::make_unique<int[]>(r*c);
auto at = [&](int i,int j){ return buf[i*c + j]; };
\end{lstlisting}
Pointer ke array dan pointer ganda digunakan untuk memanipulasi matriks dinamis dan buffer variabel. Di C, pola alokasi dua tingkat memerlukan pembebasan bertahap untuk mencegah kebocoran. Di C++, preferensikan penampung standar atau \texttt{std::unique\_ptr<T[]>} untuk menyederhanakan manajemen \parencite{iso-c-draft-n1570,cpp-reference}.

Perhitungan offset harus memperhitungkan ukuran elemen untuk menjaga korektitas. Saat memaparkan API, gunakan ukuran eksplisit dan validasi untuk mencegah akses di luar batas. Uji yang memeriksa skenario ukuran nol dan pertumbuhan bertahap membantu menstabilkan implementasi.

\section{Pointer ke Fungsi / Smart Pointers}
\subsection{Callback dan std::function}
\begin{lstlisting}[language=C, caption={Pointer ke fungsi di C}]
typedef int (*cmp_t)(const void*, const void*);
int cmp_int(const void* a, const void* b){ return (*(const int*)a - *(const int*)b); }
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={std::function dan lambda di C++}]
#include <functional>
std::function<int(int,int)> op = [](int a,int b){ return a+b; };
\end{lstlisting}

\subsection{Ringkasan Smart Pointer}
\begin{table}[h]
  \centering
  \caption{Ringkasan penunjuk pintar}
  \begin{tabular}{@{}lll@{}}
    \toprule
    Jenis & Kepemilikan & Catatan \\
    \midrule
    unique\_ptr & tunggal & murah, tidak copyable \\
    shared\_ptr & berbagi & hitung referensi; gunakan weak\_ptr untuk memutus siklus \\
    weak\_ptr & pengamat & tidak memengaruhi umur objek \\
    \bottomrule
  \end{tabular}
\end{table}
Pointer ke fungsi di C memungkinkan strategi callback dan tabel vektor, sedangkan C++ menyediakan alternatif modern seperti objek callable dan \texttt{std::function}. Penunjuk pintar mengekspresikan kepemilikan eksplisit: \texttt{unique\_ptr} untuk kepemilikan tunggal dan \texttt{shared\_ptr} untuk berbagi siklus hidup. Hindari siklus referensi dengan \texttt{weak\_ptr} jika hubungan graf tidak terarah \parencite{cpp-reference}.

Evaluasi biaya overhead penunjuk pintar dalam jalur kritis dan gunakan penunjuk mentah hanya sebagai non-owner view bila dibenarkan. Dokumentasi modern menyediakan pola yang jelas untuk memilih jenis penunjuk sesuai kebutuhan kepemilikan dan performa. Sertakan uji untuk skenario penghancuran berurutan guna mencegah kebocoran dan dangling pointer.
\subsection{Catatan Eksekusi (OnlineGDB, Lazarus, Code::Blocks)}
\begin{itemize}
  \item \textbf{OnlineGDB}: \url{https://www.onlinegdb.com/} \textrightarrow{} pilih C/C++, tempel contoh satu berkas, Run.
  \item \textbf{Lazarus (Pascal)}: tidak relevan untuk contoh lanjutan C/C++ di bab ini.
  \item \textbf{Code::Blocks (C/C++)}: Console application, pilih C/C++, tempel ke \texttt{main.c}/\texttt{main.cpp}, Build \& Run.
\end{itemize}
\end{document}
